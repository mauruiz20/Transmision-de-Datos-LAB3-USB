
projects/lab3/out/lab3.elf:     file format elf32-littlearm
projects/lab3/out/lab3.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x1a000785

Program Header:
0x70000001 off    0x00011e2c vaddr 0x1a001e2c paddr 0x1a001e2c align 2**2
         filesz 0x00000008 memsz 0x00000008 flags r--
    LOAD off    0x00010080 vaddr 0x10000080 paddr 0x10000080 align 2**16
         filesz 0x00000000 memsz 0x00000030 flags rw-
    LOAD off    0x00010000 vaddr 0x1a000000 paddr 0x1a000000 align 2**16
         filesz 0x00001e34 memsz 0x00001e34 flags rwx
    LOAD off    0x00020000 vaddr 0x10000000 paddr 0x1a001e34 align 2**16
         filesz 0x00000080 memsz 0x00000080 flags rw-
private flags = 5000400: [Version5 EABI] [hard-float ABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001e28  1a000000  1a000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000080  10000000  1a001e34  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .data_RAM2    00000000  10080000  10080000  00020080  2**2
                  CONTENTS
  3 .data_RAM3    00000000  20000000  20000000  00020080  2**2
                  CONTENTS
  4 .data_RAM4    00000000  20008000  20008000  00020080  2**2
                  CONTENTS
  5 .data_RAM5    00000000  2000c000  2000c000  00020080  2**2
                  CONTENTS
  6 .bss          00000030  10000080  10000080  00010080  2**2
                  ALLOC
  7 .bss_RAM2     00000000  10080000  10080000  00020080  2**2
                  CONTENTS
  8 .bss_RAM3     00000000  20000000  20000000  00020080  2**2
                  CONTENTS
  9 .bss_RAM4     00000000  20008000  20008000  00020080  2**2
                  CONTENTS
 10 .bss_RAM5     00000000  2000c000  2000c000  00020080  2**2
                  CONTENTS
 11 .init_array   00000004  1a001e28  1a001e28  00011e28  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .ARM.exidx    00000008  1a001e2c  1a001e2c  00011e2c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 13 .uninit_RESERVED 00000000  10000000  10000000  00020080  2**2
                  CONTENTS
 14 .noinit_RAM2  00000000  10080000  10080000  00020080  2**2
                  CONTENTS
 15 .noinit_RAM3  00000000  20000000  20000000  00020080  2**2
                  CONTENTS
 16 .noinit_RAM4  00000000  20008000  20008000  00020080  2**2
                  CONTENTS
 17 .noinit_RAM5  00000000  2000c000  2000c000  00020080  2**2
                  CONTENTS
 18 .noinit       00000000  100000b0  100000b0  00020080  2**2
                  CONTENTS
 19 .debug_info   00011fa5  00000000  00000000  00020080  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_abbrev 00002c57  00000000  00000000  00032025  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_loc    000072f5  00000000  00000000  00034c7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_aranges 000008c8  00000000  00000000  0003bf78  2**3
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_ranges 00000920  00000000  00000000  0003c840  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_macro  00009937  00000000  00000000  0003d160  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_line   00007755  00000000  00000000  00046a97  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_str    00023274  00000000  00000000  0004e1ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .comment      00000070  00000000  00000000  00071460  2**0
                  CONTENTS, READONLY
 28 .ARM.attributes 00000039  00000000  00000000  000714d0  2**0
                  CONTENTS, READONLY
 29 .debug_frame  000013f4  00000000  00000000  0007150c  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
1a000000 l    d  .text	00000000 .text
10000000 l    d  .data	00000000 .data
10080000 l    d  .data_RAM2	00000000 .data_RAM2
20000000 l    d  .data_RAM3	00000000 .data_RAM3
20008000 l    d  .data_RAM4	00000000 .data_RAM4
2000c000 l    d  .data_RAM5	00000000 .data_RAM5
10000080 l    d  .bss	00000000 .bss
10080000 l    d  .bss_RAM2	00000000 .bss_RAM2
20000000 l    d  .bss_RAM3	00000000 .bss_RAM3
20008000 l    d  .bss_RAM4	00000000 .bss_RAM4
2000c000 l    d  .bss_RAM5	00000000 .bss_RAM5
1a001e28 l    d  .init_array	00000000 .init_array
1a001e2c l    d  .ARM.exidx	00000000 .ARM.exidx
10000000 l    d  .uninit_RESERVED	00000000 .uninit_RESERVED
10080000 l    d  .noinit_RAM2	00000000 .noinit_RAM2
20000000 l    d  .noinit_RAM3	00000000 .noinit_RAM3
20008000 l    d  .noinit_RAM4	00000000 .noinit_RAM4
2000c000 l    d  .noinit_RAM5	00000000 .noinit_RAM5
100000b0 l    d  .noinit	00000000 .noinit
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_macro	00000000 .debug_macro
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 armv7m_startup.c
00000000 l    df *ABS*	00000000 vendor_interrupt.c
00000000 l    df *ABS*	00000000 crp.c
00000000 l    df *ABS*	00000000 hid_main.c
10000080 l     O .bss	00000004 g_ep0RxBusy
10000084 l     O .bss	00000004 g_Ep0BaseHdlr
10000088 l     O .bss	00000004 g_hUsb
00000000 l    df *ABS*	00000000 hid_keyboard.c
1a00041c l     F .text	00000014 Keyboard_EpIN_Hdlr
1a000430 l     F .text	00000070 Keyboard_UpdateReport
1a0004a0 l     F .text	00000044 Keyboard_SetReport
1a0004e4 l     F .text	00000038 Keyboard_GetReport
1000008c l     O .bss	00000010 g_keyBoard
1000009c l     O .bss	00000001 presionadas
00000000 l    df *ABS*	00000000 board.c
1a000814 l     F .text	00000040 Board_LED_Init
1a000854 l     F .text	0000003c Board_TEC_Init
1a000890 l     F .text	0000003c Board_GPIO_Init
1a0008cc l     F .text	00000030 Board_ADC_Init
1a0008fc l     F .text	00000038 Board_SPI_Init
1a000934 l     F .text	00000024 Board_I2C_Init
1a001c9c l     O .text	00000012 GpioPorts
1a001cb8 l     O .text	00000008 GpioButtons
1a001cc0 l     O .text	0000000c GpioLeds
00000000 l    df *ABS*	00000000 board_sysinit.c
1a001ccc l     O .text	00000004 InitClkStates
1a001cd0 l     O .text	00000074 pinmuxing
00000000 l    df *ABS*	00000000 uart_18xx_43xx.c
1a000a80 l     F .text	0000002c Chip_UART_GetIndex
1a001d44 l     O .text	00000008 UART_BClock
1a001d4c l     O .text	00000008 UART_PClock
00000000 l    df *ABS*	00000000 adc_18xx_43xx.c
1a000be4 l     F .text	00000014 Chip_ADC_GetClockIndex
1a000bf8 l     F .text	00000030 getClkDiv
00000000 l    df *ABS*	00000000 clock_18xx_43xx.c
1a000ca8 l     F .text	000000a8 pll_calc_divs
1a000d50 l     F .text	00000104 pll_get_frac
1a000e54 l     F .text	00000048 Chip_Clock_FindBaseClock
1a0010c0 l     F .text	00000022 Chip_Clock_GetDivRate
100000a0 l     O .bss	00000008 audio_usb_pll_freq
1a001d60 l     O .text	0000006c periph_to_base
00000000 l    df *ABS*	00000000 chip_18xx_43xx.c
1a00128c l     F .text	00000034 Chip_USB_PllSetup
1a001dcc l     O .text	00000014 usbPLLSetup
00000000 l    df *ABS*	00000000 sysinit_18xx_43xx.c
1a001de0 l     O .text	00000048 InitClkStates
00000000 l    df *ABS*	00000000 gpio_18xx_43xx.c
00000000 l    df *ABS*	00000000 ssp_18xx_43xx.c
1a00145c l     F .text	00000014 Chip_SSP_GetClockIndex
1a001470 l     F .text	00000018 Chip_SSP_GetPeriphClockIndex
00000000 l    df *ABS*	00000000 i2c_18xx_43xx.c
10000048 l     O .data	00000038 i2c
00000000 l    df *ABS*	00000000 sysinit.c
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 bpabi.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 hid_desc.c
00000000 l    df *ABS*	00000000 system.c
00000000 l    df *ABS*	00000000 
1a001e2c l       .init_array	00000000 __init_array_end
1a001e28 l       .bss_RAM5	00000000 __preinit_array_end
00000000 l       *UND*	00000000 Chip_GPIO_ReadPort
1a001e28 l       .init_array	00000000 __init_array_start
1a001e28 l       .bss_RAM5	00000000 __preinit_array_start
1a000ee8 g     F .text	0000001c Chip_Clock_GetDividerSource
1a001628 g     F .text	0000002e .hidden __gnu_uldivmod_helper
1a0001cc  w    F .text	00000002 TIMER2_IRQHandler
1a000190  w    F .text	00000002 DebugMon_Handler
1a0001cc  w    F .text	00000002 RIT_IRQHandler
1a080000 g       *ABS*	00000000 __top_MFlashA512
1a0001cc  w    F .text	00000002 ADCHS_IRQHandler
1a00165c g     F .text	0000029c .hidden __divdi3
1a000114 g       .text	00000000 __section_table_start
1a0001cc  w    F .text	00000002 FLASH_EEPROM_IRQHandler
1a0001cc  w    F .text	00000002 I2C0_IRQHandler
1a0009cc g     F .text	00000008 __stdio_init
1a0012c0 g     F .text	00000034 Chip_USB0_Init
1a00017c  w    F .text	00000002 HardFault_Handler
1a000000 g       *ABS*	00000000 __vectors_start__
1a000c9c g     F .text	0000000c Chip_ADC_SetResolution
1a000198  w    F .text	00000002 SysTick_Handler
1a000780  w    F .text	00000002 initialise_monitor_handles
1a0001cc  w    F .text	00000002 SDIO_IRQHandler
1a0001cc  w    F .text	00000002 ATIMER_IRQHandler
1a000194  w    F .text	00000002 PendSV_Handler
1a000178  w    F .text	00000002 NMI_Handler
1a001e34 g       .ARM.exidx	00000000 __exidx_end
1a000150 g       .text	00000000 __data_section_table_end
1a0001cc  w    F .text	00000002 I2C1_IRQHandler
1a0001cc  w    F .text	00000002 UART1_IRQHandler
1a0001cc  w    F .text	00000002 GPIO5_IRQHandler
1a0001cc  w    F .text	00000002 CAN1_IRQHandler
1a00126c g     F .text	00000014 Chip_Clock_EnablePLL
53ff70f6 g       *ABS*	00000000 __valid_user_code_checksum
1a001e34 g       .ARM.exidx	00000000 _etext
1a0001cc  w    F .text	00000002 USB1_IRQHandler
1a00051c g     F .text	000000f8 Buttons_Init
1a0001cc  w    F .text	00000002 I2S0_IRQHandler
1a001bcc g     O .text	0000007c USB_StringDescriptor
1a0001cc  w    F .text	00000002 TIMER3_IRQHandler
1a001164 g     F .text	0000000c Chip_Clock_GetBaseClocktHz
1a0001cc  w    F .text	00000002 UART0_IRQHandler
1a0001b8 g     F .text	00000012 bss_init
1a0001cc  w    F .text	00000002 SGPIO_IRQHandler
1a00122c g     F .text	00000040 Chip_Clock_SetupPLL
1a0015c8 g     F .text	00000000 .hidden __aeabi_uldivmod
100000b0 g       .noinit	00000000 _noinit
100000ac g     O .bss	00000004 SystemCoreClock
1a000aac g     F .text	00000054 Chip_UART_Init
1a0001cc  w    F .text	00000002 ADC0_IRQHandler
1a000188  w    F .text	00000002 UsageFault_Handler
1a0011e0 g     F .text	0000004c Chip_Clock_GetRate
1a0001cc  w    F .text	00000002 GPIO6_IRQHandler
1a001c88 g     O .text	00000012 USB_DeviceDescriptor
1a000a08 g     F .text	0000006c Board_SetupClocking
20008000 g       *ABS*	00000000 __top_RamAHB32
1a001cb4 g     O .text	00000004 ExtRateIn
1a0001cc  w    F .text	00000002 IntDefaultHandler
1a000300 g       .text	00000000 __CRP_WORD_END__
1a000630 g     F .text	0000001c GPIO1_IRQHandler
1a0001cc  w    F .text	00000002 SSP0_IRQHandler
1a001e2c g       .ARM.exidx	00000000 __exidx_start
1a0002fc g     O .text	00000004 CRP_WORD
1a001b64 g     F .text	0000004c __libc_init_array
1a0018f8 g     F .text	0000026a .hidden __udivdi3
1a0001cc  w    F .text	00000002 ADC1_IRQHandler
1a0009a0 g     F .text	0000002c Board_Init
1a000810  w    F .text	00000002 _init
1a000114 g       .text	00000000 __data_section_table
1a0001cc  w    F .text	00000002 RTC_IRQHandler
100000b0 g       .bss	00000000 _ebss
1a0001cc  w    F .text	00000002 TIMER0_IRQHandler
1a000784 g     F .text	00000088 Reset_Handler
20010000 g       *ABS*	00000000 __top_RamAHB_ETB16
1a0001cc  w    F .text	00000002 SPI_IRQHandler
1a001558 g     F .text	00000030 Chip_I2C_SetClockRate
1a0001cc  w    F .text	00000002 LCD_IRQHandler
1a000e9c g     F .text	0000004c Chip_Clock_EnableCrystal
10008000 g       *ABS*	00000000 __top_RamLoc32
1a00019c g     F .text	0000001a data_init
1a000300 g     F .text	00000038 EP0_patch
1a0001cc  w    F .text	00000002 TIMER1_IRQHandler
1a001534 g     F .text	00000024 Chip_I2C_Init
1a0001cc  w    F .text	00000002 UART2_IRQHandler
1a001058 g     F .text	00000068 Chip_Clock_GetMainPLLHz
1a001488 g     F .text	00000012 Chip_SSP_SetClockRate
1a001bca g     O .text	00000002 Keyboard_ReportDescSize
1a00064c g     F .text	0000001c GPIO2_IRQHandler
1a001140 g     F .text	00000024 Chip_Clock_GetBaseClock
1a001280 g     F .text	0000000c Chip_Clock_GetPLLStatus
10000080 g       .bss	00000000 _bss
1a000c68 g     F .text	00000032 Chip_ADC_SetSampleRate
1a0001cc  w    F .text	00000002 I2S1_IRQHandler
1a00149c g     F .text	0000003e Chip_SSP_SetBitRate
1a001458 g     F .text	00000002 Chip_GPIO_Init
1a000684 g     F .text	000000b8 Keyboard_init
1a001cb0 g     O .text	00000004 OscRateIn
100000b0 g       .noinit	00000000 _end_noinit
10008000 g       *ABS*	00000000 _vStackTop
1a0001cc  w    F .text	00000002 SSP1_IRQHandler
1a000178 g       .text	00000000 __bss_section_table_end
1a001658  w    F .text	00000002 .hidden __aeabi_ldiv0
1a000338 g     F .text	0000001c USB0_IRQHandler
1a000668 g     F .text	0000001c GPIO3_IRQHandler
1a0001cc  w    F .text	00000002 SCT_IRQHandler
1a000f04 g     F .text	0000001c Chip_Clock_GetDividerDivisor
1a0002fc g       .text	00000000 __CRP_WORD_START__
1a001bb0 g     F .text	00000010 memset
1a000180  w    F .text	00000002 MemManage_Handler
1a000354 g     F .text	000000c8 main
1a0001cc  w    F .text	00000002 WDT_IRQHandler
2000c000 g       *ABS*	00000000 __top_RamAHB16
1008a000 g       *ABS*	00000000 __top_RamLoc40
1a00018c  w    F .text	00000002 SVC_Handler
1a00073c g     F .text	00000044 Keyboard_Tasks
1a0001cc  w    F .text	00000002 GPIO7_IRQHandler
1a001170 g     F .text	0000003c Chip_Clock_EnableOpts
1a001c48 g     O .text	0000003f Keyboard_ReportDescriptor
1a000f20 g     F .text	000000b8 Chip_Clock_GetClockInputHz
1a000fd8 g     F .text	00000080 Chip_Clock_CalcMainPLLValue
1a001bc0 g     O .text	0000000a USB_DeviceQualifier
1a001588 g     F .text	00000040 SystemInit
1a0001cc  w    F .text	00000002 SPIFI_IRQHandler
1a0001cc  w    F .text	00000002 QEI_IRQHandler
1a000150 g       .text	00000000 __bss_section_table
1a00080c  w    F .text	00000002 _fini
1a000c28 g     F .text	00000040 Chip_ADC_Init
100000a8 g     O .bss	00000004 g_pUsbApi
1a0009d4 g     F .text	00000034 Board_SetupMuxing
1a000b00 g     F .text	000000e4 Chip_UART_SetBaudFDR
1a0001cc  w    F .text	00000002 ETH_IRQHandler
10000000 g       .uninit_RESERVED	00000000 _end_uninit_RESERVED
1a0001cc  w    F .text	00000002 CAN0_IRQHandler
10000000 g       .data	00000000 _data
10000000 g     O .data	00000023 USB_HsConfigDescriptor
100000b0 g       .bss	00000000 _pvHeapStart
1a000178 g       .text	00000000 __section_table_end
1a0014dc g     F .text	00000038 Chip_SSP_Init
1a0001cc  w    F .text	00000002 GINT0_IRQHandler
1a0001cc  w    F .text	00000002 DAC_IRQHandler
1a000958 g     F .text	00000024 Board_Debug_Init
10000080 g       .data	00000000 _edata
1a001514 g     F .text	00000020 Chip_I2C_EventHandler
1a0001cc  w    F .text	00000002 M0SUB_IRQHandler
1a001308 g     F .text	00000150 Chip_SetupCoreClock
10000024 g     O .data	00000023 USB_FsConfigDescriptor
1a000614 g     F .text	0000001c GPIO0_IRQHandler
1a000000 g     O .text	00000040 g_pfnVectors
1a0012f4 g     F .text	00000014 SystemCoreClockUpdate
1a0001cc  w    F .text	00000002 DMA_IRQHandler
1a0001cc  w    F .text	00000002 EVRT_IRQHandler
1b080000 g       *ABS*	00000000 __top_MFlashB512
1a001658  w    F .text	00000002 .hidden __aeabi_idiv0
1a000184  w    F .text	00000002 BusFault_Handler
1a0011ac g     F .text	00000034 Chip_Clock_Enable
1a0001cc  w    F .text	00000002 UART3_IRQHandler
1a0001cc  w    F .text	00000002 MCPWM_IRQHandler
1a0015f8 g     F .text	0000002e .hidden __gnu_ldivmod_helper
1a00097c g     F .text	00000024 Board_LED_Set
1a0001cc  w    F .text	00000002 M0APP_IRQHandler
1a000040 g     O .text	000000d4 g_pfnVendorVectors
1a0001cc  w    F .text	00000002 GINT1_IRQHandler
1a001128 g     F .text	00000018 Chip_Clock_EnableBaseClock
1a0010e4 g     F .text	00000044 Chip_Clock_SetBaseClock
1a0001cc  w    F .text	00000002 GPIO4_IRQHandler
1a000a74 g     F .text	0000000c Board_SystemInit



Disassembly of section .text:

1a000000 <g_pfnVectors>:
1a000000:	00 80 00 10 85 07 00 1a 79 01 00 1a 7d 01 00 1a     ........y...}...
1a000010:	81 01 00 1a 85 01 00 1a 89 01 00 1a f6 70 ff 53     .............p.S
	...
1a00002c:	8d 01 00 1a 91 01 00 1a 00 00 00 00 95 01 00 1a     ................
1a00003c:	99 01 00 1a                                         ....

1a000040 <g_pfnVendorVectors>:
1a000040:	cd 01 00 1a cd 01 00 1a cd 01 00 1a 00 00 00 00     ................
1a000050:	cd 01 00 1a cd 01 00 1a cd 01 00 1a cd 01 00 1a     ................
1a000060:	39 03 00 1a cd 01 00 1a cd 01 00 1a cd 01 00 1a     9...............
1a000070:	cd 01 00 1a cd 01 00 1a cd 01 00 1a cd 01 00 1a     ................
1a000080:	cd 01 00 1a cd 01 00 1a cd 01 00 1a cd 01 00 1a     ................
1a000090:	cd 01 00 1a cd 01 00 1a cd 01 00 1a cd 01 00 1a     ................
1a0000a0:	cd 01 00 1a cd 01 00 1a cd 01 00 1a cd 01 00 1a     ................
1a0000b0:	cd 01 00 1a cd 01 00 1a cd 01 00 1a cd 01 00 1a     ................
1a0000c0:	15 06 00 1a 31 06 00 1a 4d 06 00 1a 69 06 00 1a     ....1...M...i...
1a0000d0:	cd 01 00 1a cd 01 00 1a cd 01 00 1a cd 01 00 1a     ................
1a0000e0:	cd 01 00 1a cd 01 00 1a cd 01 00 1a cd 01 00 1a     ................
1a0000f0:	00 00 00 00 cd 01 00 1a cd 01 00 1a cd 01 00 1a     ................
1a000100:	00 00 00 00 cd 01 00 1a cd 01 00 1a cd 01 00 1a     ................
1a000110:	cd 01 00 1a                                         ....

1a000114 <__data_section_table>:
1a000114:	1a001e34 	.word	0x1a001e34
1a000118:	10000000 	.word	0x10000000
1a00011c:	00000080 	.word	0x00000080
1a000120:	1a001e34 	.word	0x1a001e34
1a000124:	10080000 	.word	0x10080000
1a000128:	00000000 	.word	0x00000000
1a00012c:	1a001e34 	.word	0x1a001e34
1a000130:	20000000 	.word	0x20000000
1a000134:	00000000 	.word	0x00000000
1a000138:	1a001e34 	.word	0x1a001e34
1a00013c:	20008000 	.word	0x20008000
1a000140:	00000000 	.word	0x00000000
1a000144:	1a001e34 	.word	0x1a001e34
1a000148:	2000c000 	.word	0x2000c000
1a00014c:	00000000 	.word	0x00000000

1a000150 <__bss_section_table>:
1a000150:	10000080 	.word	0x10000080
1a000154:	00000030 	.word	0x00000030
1a000158:	10080000 	.word	0x10080000
1a00015c:	00000000 	.word	0x00000000
1a000160:	20000000 	.word	0x20000000
1a000164:	00000000 	.word	0x00000000
1a000168:	20008000 	.word	0x20008000
1a00016c:	00000000 	.word	0x00000000
1a000170:	2000c000 	.word	0x2000c000
1a000174:	00000000 	.word	0x00000000

1a000178 <NMI_Handler>:
}

__attribute__ ((section(".after_vectors")))
void NMI_Handler(void) {
    while (1) {
    }
1a000178:	e7fe      	b.n	1a000178 <NMI_Handler>
1a00017a:	bf00      	nop

1a00017c <HardFault_Handler>:
}
__attribute__ ((section(".after_vectors")))
void HardFault_Handler(void) {
    while (1) {
    }
1a00017c:	e7fe      	b.n	1a00017c <HardFault_Handler>
1a00017e:	bf00      	nop

1a000180 <MemManage_Handler>:
}
__attribute__ ((section(".after_vectors")))
void MemManage_Handler(void) {
    while (1) {
    }
1a000180:	e7fe      	b.n	1a000180 <MemManage_Handler>
1a000182:	bf00      	nop

1a000184 <BusFault_Handler>:
}
__attribute__ ((section(".after_vectors")))
void BusFault_Handler(void) {
    while (1) {
    }
1a000184:	e7fe      	b.n	1a000184 <BusFault_Handler>
1a000186:	bf00      	nop

1a000188 <UsageFault_Handler>:
}
__attribute__ ((section(".after_vectors")))
void UsageFault_Handler(void) {
    while (1) {
    }
1a000188:	e7fe      	b.n	1a000188 <UsageFault_Handler>
1a00018a:	bf00      	nop

1a00018c <SVC_Handler>:
}
__attribute__ ((section(".after_vectors")))
void SVC_Handler(void) {
    while (1) {
    }
1a00018c:	e7fe      	b.n	1a00018c <SVC_Handler>
1a00018e:	bf00      	nop

1a000190 <DebugMon_Handler>:
}
__attribute__ ((section(".after_vectors")))
void DebugMon_Handler(void) {
    while (1) {
    }
1a000190:	e7fe      	b.n	1a000190 <DebugMon_Handler>
1a000192:	bf00      	nop

1a000194 <PendSV_Handler>:
}
__attribute__ ((section(".after_vectors")))
void PendSV_Handler(void) {
    while (1) {
    }
1a000194:	e7fe      	b.n	1a000194 <PendSV_Handler>
1a000196:	bf00      	nop

1a000198 <SysTick_Handler>:
}
__attribute__ ((section(".after_vectors")))
void SysTick_Handler(void) {
    while (1) {
    }
1a000198:	e7fe      	b.n	1a000198 <SysTick_Handler>
1a00019a:	bf00      	nop

1a00019c <data_init>:
    PendSV_Handler,                 // The PendSV handler
    SysTick_Handler,                // The SysTick handler
};

__attribute__((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
1a00019c:	b410      	push	{r4}
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
1a00019e:	2300      	movs	r3, #0
1a0001a0:	e004      	b.n	1a0001ac <data_init+0x10>
        *pulDest++ = *pulSrc++;
1a0001a2:	6804      	ldr	r4, [r0, #0]
1a0001a4:	600c      	str	r4, [r1, #0]
__attribute__((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
1a0001a6:	3304      	adds	r3, #4
        *pulDest++ = *pulSrc++;
1a0001a8:	3004      	adds	r0, #4
1a0001aa:	3104      	adds	r1, #4
__attribute__((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
1a0001ac:	4293      	cmp	r3, r2
1a0001ae:	d3f8      	bcc.n	1a0001a2 <data_init+0x6>
        *pulDest++ = *pulSrc++;
}
1a0001b0:	f85d 4b04 	ldr.w	r4, [sp], #4
1a0001b4:	4770      	bx	lr
1a0001b6:	bf00      	nop

1a0001b8 <bss_init>:

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
1a0001b8:	2300      	movs	r3, #0
1a0001ba:	e003      	b.n	1a0001c4 <bss_init+0xc>
        *pulDest++ = 0;
1a0001bc:	2200      	movs	r2, #0
1a0001be:	6002      	str	r2, [r0, #0]

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
1a0001c0:	3304      	adds	r3, #4
        *pulDest++ = 0;
1a0001c2:	3004      	adds	r0, #4

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
1a0001c4:	428b      	cmp	r3, r1
1a0001c6:	d3f9      	bcc.n	1a0001bc <bss_init+0x4>
        *pulDest++ = 0;
}
1a0001c8:	4770      	bx	lr
1a0001ca:	bf00      	nop

1a0001cc <ADC0_IRQHandler>:
};

__attribute__ ((section(".after_vectors")))
void IntDefaultHandler(void) {
    while (1) {
    }
1a0001cc:	e7fe      	b.n	1a0001cc <ADC0_IRQHandler>
1a0001ce:	bf00      	nop
1a0001d0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001d4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001d8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001dc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001e0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001e4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001e8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001ec:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001f0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001f4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001f8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0001fc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000200:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000204:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000208:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00020c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000210:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000214:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000218:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00021c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000220:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000224:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000228:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00022c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000230:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000234:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000238:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00023c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000240:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000244:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000248:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00024c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000250:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000254:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000258:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00025c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000260:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000264:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000268:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00026c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000270:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000274:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000278:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00027c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000280:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000284:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000288:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00028c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000290:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000294:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a000298:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a00029c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002a0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002a4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002a8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ac:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002b0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002b4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002b8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002bc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002c0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002c4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002c8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002cc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002d0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002d4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002d8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002dc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002e0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002e4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002e8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002ec:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002f0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002f4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
1a0002f8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

1a0002fc <CRP_WORD>:
1a0002fc:	ffff ffff                                   ....

1a000300 <EP0_patch>:
 * Private functions
 ****************************************************************************/

/* EP0_patch part of WORKAROUND for artf45032. */
ErrorCode_t EP0_patch(USBD_HANDLE_T hUsb, void *data, uint32_t event)
{
1a000300:	b510      	push	{r4, lr}
	switch (event) {
1a000302:	4613      	mov	r3, r2
1a000304:	b16a      	cbz	r2, 1a000322 <EP0_patch+0x22>
1a000306:	2a02      	cmp	r2, #2
1a000308:	d908      	bls.n	1a00031c <EP0_patch+0x1c>
1a00030a:	2a04      	cmp	r2, #4
1a00030c:	d109      	bne.n	1a000322 <EP0_patch+0x22>
	case USB_EVT_OUT_NAK:
		if (g_ep0RxBusy) {
1a00030e:	4a08      	ldr	r2, [pc, #32]	; (1a000330 <EP0_patch+0x30>)
1a000310:	6812      	ldr	r2, [r2, #0]
1a000312:	b95a      	cbnz	r2, 1a00032c <EP0_patch+0x2c>
			/* we already queued the buffer so ignore this NAK event. */
			return LPC_OK;
		}
		else {
			/* Mark EP0_RX buffer as busy and allow base handler to queue the buffer. */
			g_ep0RxBusy = 1;
1a000314:	2401      	movs	r4, #1
1a000316:	4a06      	ldr	r2, [pc, #24]	; (1a000330 <EP0_patch+0x30>)
1a000318:	6014      	str	r4, [r2, #0]
		}
		break;
1a00031a:	e002      	b.n	1a000322 <EP0_patch+0x22>

	case USB_EVT_SETUP:	/* reset the flag when new setup sequence starts */
	case USB_EVT_OUT:
		/* we received the packet so clear the flag. */
		g_ep0RxBusy = 0;
1a00031c:	2400      	movs	r4, #0
1a00031e:	4a04      	ldr	r2, [pc, #16]	; (1a000330 <EP0_patch+0x30>)
1a000320:	6014      	str	r4, [r2, #0]
1a000322:	461a      	mov	r2, r3
		break;
	}
	return g_Ep0BaseHdlr(hUsb, data, event);
1a000324:	4b03      	ldr	r3, [pc, #12]	; (1a000334 <EP0_patch+0x34>)
1a000326:	681b      	ldr	r3, [r3, #0]
1a000328:	4798      	blx	r3
1a00032a:	bd10      	pop	{r4, pc}
{
	switch (event) {
	case USB_EVT_OUT_NAK:
		if (g_ep0RxBusy) {
			/* we already queued the buffer so ignore this NAK event. */
			return LPC_OK;
1a00032c:	2000      	movs	r0, #0
		/* we received the packet so clear the flag. */
		g_ep0RxBusy = 0;
		break;
	}
	return g_Ep0BaseHdlr(hUsb, data, event);
}
1a00032e:	bd10      	pop	{r4, pc}
1a000330:	10000080 	.word	0x10000080
1a000334:	10000084 	.word	0x10000084

1a000338 <USB0_IRQHandler>:
/**
 * @brief	Handle interrupt from USB0
 * @return	Nothing
 */
void USB_IRQHandler(void)
{
1a000338:	b508      	push	{r3, lr}
	USBD_API->hw->ISR(g_hUsb);
1a00033a:	4b04      	ldr	r3, [pc, #16]	; (1a00034c <USB0_IRQHandler+0x14>)
1a00033c:	681b      	ldr	r3, [r3, #0]
1a00033e:	681b      	ldr	r3, [r3, #0]
1a000340:	68db      	ldr	r3, [r3, #12]
1a000342:	4a03      	ldr	r2, [pc, #12]	; (1a000350 <USB0_IRQHandler+0x18>)
1a000344:	6810      	ldr	r0, [r2, #0]
1a000346:	4798      	blx	r3
1a000348:	bd08      	pop	{r3, pc}
1a00034a:	bf00      	nop
1a00034c:	100000a8 	.word	0x100000a8
1a000350:	10000088 	.word	0x10000088

1a000354 <main>:
/**
 * @brief	main routine for USBD keyboard example
 * @return	Function should not exit.
 */
int main(void)
{
1a000354:	b510      	push	{r4, lr}
1a000356:	b096      	sub	sp, #88	; 0x58
	USB_CORE_DESCS_T desc;
	ErrorCode_t ret = LPC_OK;
	USB_CORE_CTRL_T *pCtrl;

	/* Initialize board and chip */
	SystemCoreClockUpdate();
1a000358:	f000 ffcc 	bl	1a0012f4 <SystemCoreClockUpdate>
	Board_Init();
1a00035c:	f000 fb20 	bl	1a0009a0 <Board_Init>

	/* enable clocks and pinmux */
	USB_init_pin_clk();
1a000360:	f000 ffae 	bl	1a0012c0 <Chip_USB0_Init>

	/* Init USB API structure */
	g_pUsbApi = (const USBD_API_T *) LPC_ROM_API->usbdApiBase;
1a000364:	4b20      	ldr	r3, [pc, #128]	; (1a0003e8 <main+0x94>)
1a000366:	69dc      	ldr	r4, [r3, #28]
1a000368:	4b20      	ldr	r3, [pc, #128]	; (1a0003ec <main+0x98>)
1a00036a:	601c      	str	r4, [r3, #0]

	/* initialize call back structures */
	memset((void *) &usb_param, 0, sizeof(USBD_API_INIT_PARAM_T));
1a00036c:	a805      	add	r0, sp, #20
1a00036e:	2100      	movs	r1, #0
1a000370:	2244      	movs	r2, #68	; 0x44
1a000372:	f001 fc1d 	bl	1a001bb0 <memset>
	usb_param.usb_reg_base = LPC_USB_BASE;
1a000376:	4b1e      	ldr	r3, [pc, #120]	; (1a0003f0 <main+0x9c>)
1a000378:	9305      	str	r3, [sp, #20]
	usb_param.mem_base = USB_STACK_MEM_BASE;
1a00037a:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
1a00037e:	9306      	str	r3, [sp, #24]
	usb_param.mem_size = USB_STACK_MEM_SIZE;
1a000380:	f44f 5300 	mov.w	r3, #8192	; 0x2000
1a000384:	9307      	str	r3, [sp, #28]
	usb_param.max_num_ep = 2;
1a000386:	2302      	movs	r3, #2
1a000388:	f88d 3020 	strb.w	r3, [sp, #32]

	/* Set the USB descriptors */
	desc.device_desc = (uint8_t *) USB_DeviceDescriptor;
1a00038c:	4b19      	ldr	r3, [pc, #100]	; (1a0003f4 <main+0xa0>)
1a00038e:	9300      	str	r3, [sp, #0]
	desc.string_desc = (uint8_t *) USB_StringDescriptor;
1a000390:	4b19      	ldr	r3, [pc, #100]	; (1a0003f8 <main+0xa4>)
1a000392:	9301      	str	r3, [sp, #4]

#ifdef USE_USB0
	desc.high_speed_desc = USB_HsConfigDescriptor;
1a000394:	4b19      	ldr	r3, [pc, #100]	; (1a0003fc <main+0xa8>)
1a000396:	9303      	str	r3, [sp, #12]
	desc.full_speed_desc = USB_FsConfigDescriptor;
1a000398:	4b19      	ldr	r3, [pc, #100]	; (1a000400 <main+0xac>)
1a00039a:	9302      	str	r3, [sp, #8]
	desc.device_qualifier = (uint8_t *) USB_DeviceQualifier;
1a00039c:	4b19      	ldr	r3, [pc, #100]	; (1a000404 <main+0xb0>)
1a00039e:	9304      	str	r3, [sp, #16]
	desc.full_speed_desc = USB_FsConfigDescriptor;
	desc.device_qualifier = 0;
#endif

	/* USB Initialization */
	ret = USBD_API->hw->Init(&g_hUsb, &desc, &usb_param);
1a0003a0:	6823      	ldr	r3, [r4, #0]
1a0003a2:	685b      	ldr	r3, [r3, #4]
1a0003a4:	4818      	ldr	r0, [pc, #96]	; (1a000408 <main+0xb4>)
1a0003a6:	4669      	mov	r1, sp
1a0003a8:	aa05      	add	r2, sp, #20
1a0003aa:	4798      	blx	r3
	if (ret == LPC_OK) {
1a0003ac:	b9c0      	cbnz	r0, 1a0003e0 <main+0x8c>
		    occur before the default endpoint0 handler has completed its preparation
		    of the DMA engine for the first NAK event. This can cause certain fields
		    in the DMA descriptors to be in an invalid state when the USB controller
		    reads them, thereby causing a hang.
		 */
		pCtrl = (USB_CORE_CTRL_T *) g_hUsb;	/* convert the handle to control structure */
1a0003ae:	4b16      	ldr	r3, [pc, #88]	; (1a000408 <main+0xb4>)
1a0003b0:	6818      	ldr	r0, [r3, #0]
		g_Ep0BaseHdlr = pCtrl->ep_event_hdlr[0];/* retrieve the default EP0_OUT handler */
1a0003b2:	6d82      	ldr	r2, [r0, #88]	; 0x58
1a0003b4:	4b15      	ldr	r3, [pc, #84]	; (1a00040c <main+0xb8>)
1a0003b6:	601a      	str	r2, [r3, #0]
		pCtrl->ep_event_hdlr[0] = EP0_patch;/* set our patch routine as EP0_OUT handler */
1a0003b8:	4b15      	ldr	r3, [pc, #84]	; (1a000410 <main+0xbc>)
1a0003ba:	6583      	str	r3, [r0, #88]	; 0x58

		ret = Keyboard_init(g_hUsb,
1a0003bc:	4915      	ldr	r1, [pc, #84]	; (1a000414 <main+0xc0>)
1a0003be:	aa06      	add	r2, sp, #24
1a0003c0:	ab07      	add	r3, sp, #28
1a0003c2:	f000 f95f 	bl	1a000684 <Keyboard_init>
							(USB_INTERFACE_DESCRIPTOR *) &USB_FsConfigDescriptor[sizeof(USB_CONFIGURATION_DESCRIPTOR)],
							&usb_param.mem_base, &usb_param.mem_size);
		if (ret == LPC_OK) {
1a0003c6:	b958      	cbnz	r0, 1a0003e0 <main+0x8c>
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
1a0003c8:	f44f 7280 	mov.w	r2, #256	; 0x100
1a0003cc:	4b12      	ldr	r3, [pc, #72]	; (1a000418 <main+0xc4>)
1a0003ce:	601a      	str	r2, [r3, #0]
			/*  enable USB interrrupts */
			NVIC_EnableIRQ(LPC_USB_IRQ);
			/* now connect */
			USBD_API->hw->Connect(g_hUsb, 1);
1a0003d0:	4b06      	ldr	r3, [pc, #24]	; (1a0003ec <main+0x98>)
1a0003d2:	681b      	ldr	r3, [r3, #0]
1a0003d4:	681b      	ldr	r3, [r3, #0]
1a0003d6:	689b      	ldr	r3, [r3, #8]
1a0003d8:	4a0b      	ldr	r2, [pc, #44]	; (1a000408 <main+0xb4>)
1a0003da:	6810      	ldr	r0, [r2, #0]
1a0003dc:	2101      	movs	r1, #1
1a0003de:	4798      	blx	r3
		}
	}

	while (1) {
		/* Do Keyboard tasks */
		Keyboard_Tasks();
1a0003e0:	f000 f9ac 	bl	1a00073c <Keyboard_Tasks>
		/* Sleep until next IRQ happens */
		__WFI();
1a0003e4:	bf30      	wfi
        }
1a0003e6:	e7fb      	b.n	1a0003e0 <main+0x8c>
1a0003e8:	10400100 	.word	0x10400100
1a0003ec:	100000a8 	.word	0x100000a8
1a0003f0:	40006000 	.word	0x40006000
1a0003f4:	1a001c88 	.word	0x1a001c88
1a0003f8:	1a001bcc 	.word	0x1a001bcc
1a0003fc:	10000000 	.word	0x10000000
1a000400:	10000024 	.word	0x10000024
1a000404:	1a001bc0 	.word	0x1a001bc0
1a000408:	10000088 	.word	0x10000088
1a00040c:	10000084 	.word	0x10000084
1a000410:	1a000301 	.word	0x1a000301
1a000414:	1000002d 	.word	0x1000002d
1a000418:	e000e100 	.word	0xe000e100

1a00041c <Keyboard_EpIN_Hdlr>:
}

//HID interrupt IN endpoint handler
static ErrorCode_t Keyboard_EpIN_Hdlr(USBD_HANDLE_T hUsb, void *data, uint32_t event)
{
	switch (event) {
1a00041c:	2a03      	cmp	r2, #3
1a00041e:	d102      	bne.n	1a000426 <Keyboard_EpIN_Hdlr+0xa>
	case USB_EVT_IN:
		g_keyBoard.tx_busy = 0;
1a000420:	2200      	movs	r2, #0
1a000422:	4b02      	ldr	r3, [pc, #8]	; (1a00042c <Keyboard_EpIN_Hdlr+0x10>)
1a000424:	731a      	strb	r2, [r3, #12]
		break;
	}
	return LPC_OK;
}
1a000426:	2000      	movs	r0, #0
1a000428:	4770      	bx	lr
1a00042a:	bf00      	nop
1a00042c:	1000008c 	.word	0x1000008c

1a000430 <Keyboard_UpdateReport>:


//Routine to update keyboard state
static void Keyboard_UpdateReport(void)
{
	HID_KEYBOARD_CLEAR_REPORT(&g_keyBoard.report[0]);
1a000430:	4a19      	ldr	r2, [pc, #100]	; (1a000498 <Keyboard_UpdateReport+0x68>)
1a000432:	2300      	movs	r3, #0
1a000434:	6053      	str	r3, [r2, #4]
1a000436:	6093      	str	r3, [r2, #8]

	if(presionadas & (1<<0)){
1a000438:	4b18      	ldr	r3, [pc, #96]	; (1a00049c <Keyboard_UpdateReport+0x6c>)
1a00043a:	781b      	ldrb	r3, [r3, #0]
1a00043c:	f013 0f01 	tst.w	r3, #1
1a000440:	d005      	beq.n	1a00044e <Keyboard_UpdateReport+0x1e>
		HID_KEYBOARD_REPORT_SET_KEY_PRESS(g_keyBoard.report, 0x14 );
1a000442:	2114      	movs	r1, #20
1a000444:	7191      	strb	r1, [r2, #6]
		presionadas = presionadas & 0xFE; 
1a000446:	f023 0301 	bic.w	r3, r3, #1
1a00044a:	4a14      	ldr	r2, [pc, #80]	; (1a00049c <Keyboard_UpdateReport+0x6c>)
1a00044c:	7013      	strb	r3, [r2, #0]
	}
	if(presionadas & (1<<1)){
1a00044e:	4b13      	ldr	r3, [pc, #76]	; (1a00049c <Keyboard_UpdateReport+0x6c>)
1a000450:	781b      	ldrb	r3, [r3, #0]
1a000452:	f013 0f02 	tst.w	r3, #2
1a000456:	d006      	beq.n	1a000466 <Keyboard_UpdateReport+0x36>
		HID_KEYBOARD_REPORT_SET_KEY_PRESS(g_keyBoard.report, 0x1A );
1a000458:	211a      	movs	r1, #26
1a00045a:	4a0f      	ldr	r2, [pc, #60]	; (1a000498 <Keyboard_UpdateReport+0x68>)
1a00045c:	7191      	strb	r1, [r2, #6]
		presionadas = presionadas & 0xFD;
1a00045e:	f023 0302 	bic.w	r3, r3, #2
1a000462:	4a0e      	ldr	r2, [pc, #56]	; (1a00049c <Keyboard_UpdateReport+0x6c>)
1a000464:	7013      	strb	r3, [r2, #0]
	}
	if(presionadas & (1<<2)){
1a000466:	4b0d      	ldr	r3, [pc, #52]	; (1a00049c <Keyboard_UpdateReport+0x6c>)
1a000468:	781b      	ldrb	r3, [r3, #0]
1a00046a:	f013 0f04 	tst.w	r3, #4
1a00046e:	d006      	beq.n	1a00047e <Keyboard_UpdateReport+0x4e>
		HID_KEYBOARD_REPORT_SET_KEY_PRESS(g_keyBoard.report, 0x08 );	
1a000470:	2108      	movs	r1, #8
1a000472:	4a09      	ldr	r2, [pc, #36]	; (1a000498 <Keyboard_UpdateReport+0x68>)
1a000474:	7191      	strb	r1, [r2, #6]
		presionadas = presionadas & 0xFB;
1a000476:	f023 0304 	bic.w	r3, r3, #4
1a00047a:	4a08      	ldr	r2, [pc, #32]	; (1a00049c <Keyboard_UpdateReport+0x6c>)
1a00047c:	7013      	strb	r3, [r2, #0]
	}
	if(presionadas & (1<<3)){
1a00047e:	4b07      	ldr	r3, [pc, #28]	; (1a00049c <Keyboard_UpdateReport+0x6c>)
1a000480:	781b      	ldrb	r3, [r3, #0]
1a000482:	f013 0f08 	tst.w	r3, #8
1a000486:	d006      	beq.n	1a000496 <Keyboard_UpdateReport+0x66>
		HID_KEYBOARD_REPORT_SET_KEY_PRESS(g_keyBoard.report, 0x15 );	
1a000488:	2115      	movs	r1, #21
1a00048a:	4a03      	ldr	r2, [pc, #12]	; (1a000498 <Keyboard_UpdateReport+0x68>)
1a00048c:	7191      	strb	r1, [r2, #6]
		presionadas = presionadas & 0xF7;
1a00048e:	f023 0308 	bic.w	r3, r3, #8
1a000492:	4a02      	ldr	r2, [pc, #8]	; (1a00049c <Keyboard_UpdateReport+0x6c>)
1a000494:	7013      	strb	r3, [r2, #0]
1a000496:	4770      	bx	lr
1a000498:	1000008c 	.word	0x1000008c
1a00049c:	1000009c 	.word	0x1000009c

1a0004a0 <Keyboard_SetReport>:

//HID Set Report Request Callback. Called automatically on HID Set Report Request
static ErrorCode_t Keyboard_SetReport(USBD_HANDLE_T hHid, USB_SETUP_PACKET *pSetup, uint8_t * *pBuffer, uint16_t length)
{
	/* we will reuse standard EP0Buf */
	if (length == 0) {
1a0004a0:	b1d3      	cbz	r3, 1a0004d8 <Keyboard_SetReport+0x38>
	return LPC_OK;
}

//HID Set Report Request Callback. Called automatically on HID Set Report Request
static ErrorCode_t Keyboard_SetReport(USBD_HANDLE_T hHid, USB_SETUP_PACKET *pSetup, uint8_t * *pBuffer, uint16_t length)
{
1a0004a2:	b508      	push	{r3, lr}
	/* we will reuse standard EP0Buf */
	if (length == 0) {
		return LPC_OK;
	}
	/* ReportID = SetupPacket.wValue.WB.L; */
	switch (pSetup->wValue.WB.H) {
1a0004a4:	78cb      	ldrb	r3, [r1, #3]
1a0004a6:	2b02      	cmp	r3, #2
1a0004a8:	d005      	beq.n	1a0004b6 <Keyboard_SetReport+0x16>
1a0004aa:	2b03      	cmp	r3, #3
1a0004ac:	d001      	beq.n	1a0004b2 <Keyboard_SetReport+0x12>
1a0004ae:	2b01      	cmp	r3, #1
1a0004b0:	d114      	bne.n	1a0004dc <Keyboard_SetReport+0x3c>
		}
		break;

	case HID_REPORT_INPUT:				/* Not Supported */
	case HID_REPORT_FEATURE:			/* Not Supported */
		return ERR_USBD_STALL;
1a0004b2:	480b      	ldr	r0, [pc, #44]	; (1a0004e0 <Keyboard_SetReport+0x40>)
1a0004b4:	bd08      	pop	{r3, pc}
	switch (pSetup->wValue.WB.H) {
	case HID_REPORT_OUTPUT:
		/*  If the USB host tells us to turn on the NUM LOCK LED,
		 *  then turn on LED#2.
		 */
		if (**pBuffer & 0x01) {
1a0004b6:	6813      	ldr	r3, [r2, #0]
1a0004b8:	781b      	ldrb	r3, [r3, #0]
1a0004ba:	f013 0f01 	tst.w	r3, #1
1a0004be:	d005      	beq.n	1a0004cc <Keyboard_SetReport+0x2c>
			Board_LED_Set(GREEN_LED, 1);
1a0004c0:	2005      	movs	r0, #5
1a0004c2:	2101      	movs	r1, #1
1a0004c4:	f000 fa5a 	bl	1a00097c <Board_LED_Set>

	case HID_REPORT_INPUT:				/* Not Supported */
	case HID_REPORT_FEATURE:			/* Not Supported */
		return ERR_USBD_STALL;
	}
	return LPC_OK;
1a0004c8:	2000      	movs	r0, #0
1a0004ca:	bd08      	pop	{r3, pc}
		 */
		if (**pBuffer & 0x01) {
			Board_LED_Set(GREEN_LED, 1);
		}
		else {
			Board_LED_Set(GREEN_LED, 0);
1a0004cc:	2005      	movs	r0, #5
1a0004ce:	2100      	movs	r1, #0
1a0004d0:	f000 fa54 	bl	1a00097c <Board_LED_Set>

	case HID_REPORT_INPUT:				/* Not Supported */
	case HID_REPORT_FEATURE:			/* Not Supported */
		return ERR_USBD_STALL;
	}
	return LPC_OK;
1a0004d4:	2000      	movs	r0, #0
1a0004d6:	bd08      	pop	{r3, pc}
//HID Set Report Request Callback. Called automatically on HID Set Report Request
static ErrorCode_t Keyboard_SetReport(USBD_HANDLE_T hHid, USB_SETUP_PACKET *pSetup, uint8_t * *pBuffer, uint16_t length)
{
	/* we will reuse standard EP0Buf */
	if (length == 0) {
		return LPC_OK;
1a0004d8:	2000      	movs	r0, #0
	case HID_REPORT_INPUT:				/* Not Supported */
	case HID_REPORT_FEATURE:			/* Not Supported */
		return ERR_USBD_STALL;
	}
	return LPC_OK;
}
1a0004da:	4770      	bx	lr

	case HID_REPORT_INPUT:				/* Not Supported */
	case HID_REPORT_FEATURE:			/* Not Supported */
		return ERR_USBD_STALL;
	}
	return LPC_OK;
1a0004dc:	2000      	movs	r0, #0
}
1a0004de:	bd08      	pop	{r3, pc}
1a0004e0:	00040003 	.word	0x00040003

1a0004e4 <Keyboard_GetReport>:
									  USB_SETUP_PACKET *pSetup,
									  uint8_t * *pBuffer,
									  uint16_t *plength)
{
	/* ReportID = SetupPacket.wValue.WB.L; */
	switch (pSetup->wValue.WB.H) {
1a0004e4:	78c9      	ldrb	r1, [r1, #3]
1a0004e6:	2901      	cmp	r1, #1
1a0004e8:	d004      	beq.n	1a0004f4 <Keyboard_GetReport+0x10>
1a0004ea:	b189      	cbz	r1, 1a000510 <Keyboard_GetReport+0x2c>
1a0004ec:	2903      	cmp	r1, #3
1a0004ee:	d80f      	bhi.n	1a000510 <Keyboard_GetReport+0x2c>
		*plength = KEYBOARD_REPORT_SIZE;
		break;

	case HID_REPORT_OUTPUT:				/* Not Supported */
	case HID_REPORT_FEATURE:			/* Not Supported */
		return ERR_USBD_STALL;
1a0004f0:	4808      	ldr	r0, [pc, #32]	; (1a000514 <Keyboard_GetReport+0x30>)
	}
	return LPC_OK;
}
1a0004f2:	4770      	bx	lr
//HID Get Report Request Callback. Called automatically on HID Get Report Request
static ErrorCode_t Keyboard_GetReport(USBD_HANDLE_T hHid,
									  USB_SETUP_PACKET *pSetup,
									  uint8_t * *pBuffer,
									  uint16_t *plength)
{
1a0004f4:	b538      	push	{r3, r4, r5, lr}
1a0004f6:	461c      	mov	r4, r3
1a0004f8:	4615      	mov	r5, r2
	/* ReportID = SetupPacket.wValue.WB.L; */
	switch (pSetup->wValue.WB.H) {
	case HID_REPORT_INPUT:
		Keyboard_UpdateReport();
1a0004fa:	f7ff ff99 	bl	1a000430 <Keyboard_UpdateReport>
		memcpy(*pBuffer, &g_keyBoard.report[0], KEYBOARD_REPORT_SIZE);
1a0004fe:	682a      	ldr	r2, [r5, #0]
1a000500:	4b05      	ldr	r3, [pc, #20]	; (1a000518 <Keyboard_GetReport+0x34>)
1a000502:	cb03      	ldmia	r3!, {r0, r1}
1a000504:	6010      	str	r0, [r2, #0]
1a000506:	6051      	str	r1, [r2, #4]
		*plength = KEYBOARD_REPORT_SIZE;
1a000508:	2308      	movs	r3, #8
1a00050a:	8023      	strh	r3, [r4, #0]

	case HID_REPORT_OUTPUT:				/* Not Supported */
	case HID_REPORT_FEATURE:			/* Not Supported */
		return ERR_USBD_STALL;
	}
	return LPC_OK;
1a00050c:	2000      	movs	r0, #0
	switch (pSetup->wValue.WB.H) {
	case HID_REPORT_INPUT:
		Keyboard_UpdateReport();
		memcpy(*pBuffer, &g_keyBoard.report[0], KEYBOARD_REPORT_SIZE);
		*plength = KEYBOARD_REPORT_SIZE;
		break;
1a00050e:	bd38      	pop	{r3, r4, r5, pc}

	case HID_REPORT_OUTPUT:				/* Not Supported */
	case HID_REPORT_FEATURE:			/* Not Supported */
		return ERR_USBD_STALL;
	}
	return LPC_OK;
1a000510:	2000      	movs	r0, #0
1a000512:	4770      	bx	lr
1a000514:	00040003 	.word	0x00040003
1a000518:	10000090 	.word	0x10000090

1a00051c <Buttons_Init>:
extern const uint8_t Keyboard_ReportDescriptor[];
extern const uint16_t Keyboard_ReportDescSize;

static uint8_t presionadas = 0;

void Buttons_Init(void){
1a00051c:	b5f0      	push	{r4, r5, r6, r7, lr}
 * @note	Do not use for clock pins (SFSCLK0 .. SFSCLK4). Use
 * Chip_SCU_ClockPinMux() function for SFSCLKx clock pins.
 */
STATIC INLINE void Chip_SCU_PinMuxSet(uint8_t port, uint8_t pin, uint16_t modefunc)
{
	LPC_SCU->SFSP[port][pin] = modefunc;
1a00051e:	4a39      	ldr	r2, [pc, #228]	; (1a000604 <Buttons_Init+0xe8>)
1a000520:	26c0      	movs	r6, #192	; 0xc0
1a000522:	f8c2 6080 	str.w	r6, [r2, #128]	; 0x80
 * @param	pin		: GPIO pin to set direction on as input
 * @return	Nothing
 */
STATIC INLINE void Chip_GPIO_SetPinDIRInput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
{
	pGPIO->DIR[port] &= ~(1UL << pin);
1a000526:	4f38      	ldr	r7, [pc, #224]	; (1a000608 <Buttons_Init+0xec>)
1a000528:	f507 5000 	add.w	r0, r7, #8192	; 0x2000
1a00052c:	6803      	ldr	r3, [r0, #0]
1a00052e:	f023 0310 	bic.w	r3, r3, #16
1a000532:	6003      	str	r3, [r0, #0]
 */
STATIC INLINE void Chip_SCU_GPIOIntPinSel(uint8_t PortSel, uint8_t PortNum, uint8_t PinNum)
{
	int32_t of = (PortSel & 3) << 3;
	uint32_t val = (((PortNum & 0x7) << 5) | (PinNum & 0x1F)) << of;
	LPC_SCU->PINTSEL[PortSel >> 2] = (LPC_SCU->PINTSEL[PortSel >> 2] & ~(0xFF << of)) | val;
1a000534:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
1a000538:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
1a00053c:	f043 0304 	orr.w	r3, r3, #4
1a000540:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
 * @param	pins	: Pin interrupts to clear (ORed value of PININTCH*)
 * @return	Nothing
 */
STATIC INLINE void Chip_PININT_ClearIntStatus(LPC_PIN_INT_T *pPININT, uint32_t pins)
{
	pPININT->IST = pins;
1a000544:	4b31      	ldr	r3, [pc, #196]	; (1a00060c <Buttons_Init+0xf0>)
1a000546:	2501      	movs	r5, #1
1a000548:	625d      	str	r5, [r3, #36]	; 0x24
 * @param	pins	: Pins (ORed value of PININTCH*)
 * @return	Nothing
 */
STATIC INLINE void Chip_PININT_SetPinModeEdge(LPC_PIN_INT_T *pPININT, uint32_t pins)
{
	pPININT->ISEL &= ~pins;
1a00054a:	6819      	ldr	r1, [r3, #0]
1a00054c:	f021 0101 	bic.w	r1, r1, #1
1a000550:	6019      	str	r1, [r3, #0]
 * @param	pins	: Pins to enable (ORed value of PININTCH*)
 * @return	Nothing
 */
STATIC INLINE void Chip_PININT_EnableIntLow(LPC_PIN_INT_T *pPININT, uint32_t pins)
{
	pPININT->SIENF = pins;
1a000552:	615d      	str	r5, [r3, #20]
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
1a000554:	492e      	ldr	r1, [pc, #184]	; (1a000610 <Buttons_Init+0xf4>)
1a000556:	f8c1 5184 	str.w	r5, [r1, #388]	; 0x184
 * @note	Do not use for clock pins (SFSCLK0 .. SFSCLK4). Use
 * Chip_SCU_ClockPinMux() function for SFSCLKx clock pins.
 */
STATIC INLINE void Chip_SCU_PinMuxSet(uint8_t port, uint8_t pin, uint16_t modefunc)
{
	LPC_SCU->SFSP[port][pin] = modefunc;
1a00055a:	f8c2 6084 	str.w	r6, [r2, #132]	; 0x84
1a00055e:	6804      	ldr	r4, [r0, #0]
1a000560:	f424 7480 	bic.w	r4, r4, #256	; 0x100
1a000564:	6004      	str	r4, [r0, #0]
 */
STATIC INLINE void Chip_SCU_GPIOIntPinSel(uint8_t PortSel, uint8_t PortNum, uint8_t PinNum)
{
	int32_t of = (PortSel & 3) << 3;
	uint32_t val = (((PortNum & 0x7) << 5) | (PinNum & 0x1F)) << of;
	LPC_SCU->PINTSEL[PortSel >> 2] = (LPC_SCU->PINTSEL[PortSel >> 2] & ~(0xFF << of)) | val;
1a000566:	f8d2 4e00 	ldr.w	r4, [r2, #3584]	; 0xe00
1a00056a:	f424 447f 	bic.w	r4, r4, #65280	; 0xff00
1a00056e:	f444 6400 	orr.w	r4, r4, #2048	; 0x800
1a000572:	f8c2 4e00 	str.w	r4, [r2, #3584]	; 0xe00
 * @param	pins	: Pin interrupts to clear (ORed value of PININTCH*)
 * @return	Nothing
 */
STATIC INLINE void Chip_PININT_ClearIntStatus(LPC_PIN_INT_T *pPININT, uint32_t pins)
{
	pPININT->IST = pins;
1a000576:	2402      	movs	r4, #2
1a000578:	625c      	str	r4, [r3, #36]	; 0x24
 * @param	pins	: Pins (ORed value of PININTCH*)
 * @return	Nothing
 */
STATIC INLINE void Chip_PININT_SetPinModeEdge(LPC_PIN_INT_T *pPININT, uint32_t pins)
{
	pPININT->ISEL &= ~pins;
1a00057a:	f8d3 e000 	ldr.w	lr, [r3]
1a00057e:	f02e 0e02 	bic.w	lr, lr, #2
1a000582:	f8c3 e000 	str.w	lr, [r3]
 * @param	pins	: Pins to enable (ORed value of PININTCH*)
 * @return	Nothing
 */
STATIC INLINE void Chip_PININT_EnableIntLow(LPC_PIN_INT_T *pPININT, uint32_t pins)
{
	pPININT->SIENF = pins;
1a000586:	615c      	str	r4, [r3, #20]
1a000588:	f8c1 4184 	str.w	r4, [r1, #388]	; 0x184
 * @note	Do not use for clock pins (SFSCLK0 .. SFSCLK4). Use
 * Chip_SCU_ClockPinMux() function for SFSCLKx clock pins.
 */
STATIC INLINE void Chip_SCU_PinMuxSet(uint8_t port, uint8_t pin, uint16_t modefunc)
{
	LPC_SCU->SFSP[port][pin] = modefunc;
1a00058c:	f8c2 6088 	str.w	r6, [r2, #136]	; 0x88
1a000590:	f8d0 e000 	ldr.w	lr, [r0]
1a000594:	f42e 7e00 	bic.w	lr, lr, #512	; 0x200
1a000598:	f8c0 e000 	str.w	lr, [r0]
 */
STATIC INLINE void Chip_SCU_GPIOIntPinSel(uint8_t PortSel, uint8_t PortNum, uint8_t PinNum)
{
	int32_t of = (PortSel & 3) << 3;
	uint32_t val = (((PortNum & 0x7) << 5) | (PinNum & 0x1F)) << of;
	LPC_SCU->PINTSEL[PortSel >> 2] = (LPC_SCU->PINTSEL[PortSel >> 2] & ~(0xFF << of)) | val;
1a00059c:	f8d2 0e00 	ldr.w	r0, [r2, #3584]	; 0xe00
1a0005a0:	f420 007f 	bic.w	r0, r0, #16711680	; 0xff0000
1a0005a4:	f440 2010 	orr.w	r0, r0, #589824	; 0x90000
1a0005a8:	f8c2 0e00 	str.w	r0, [r2, #3584]	; 0xe00
 * @param	pins	: Pin interrupts to clear (ORed value of PININTCH*)
 * @return	Nothing
 */
STATIC INLINE void Chip_PININT_ClearIntStatus(LPC_PIN_INT_T *pPININT, uint32_t pins)
{
	pPININT->IST = pins;
1a0005ac:	f04f 0e04 	mov.w	lr, #4
1a0005b0:	f8c3 e024 	str.w	lr, [r3, #36]	; 0x24
 * @param	pins	: Pins (ORed value of PININTCH*)
 * @return	Nothing
 */
STATIC INLINE void Chip_PININT_SetPinModeEdge(LPC_PIN_INT_T *pPININT, uint32_t pins)
{
	pPININT->ISEL &= ~pins;
1a0005b4:	6818      	ldr	r0, [r3, #0]
1a0005b6:	f020 0004 	bic.w	r0, r0, #4
1a0005ba:	6018      	str	r0, [r3, #0]
 * @param	pins	: Pins to enable (ORed value of PININTCH*)
 * @return	Nothing
 */
STATIC INLINE void Chip_PININT_EnableIntLow(LPC_PIN_INT_T *pPININT, uint32_t pins)
{
	pPININT->SIENF = pins;
1a0005bc:	f8c3 e014 	str.w	lr, [r3, #20]
1a0005c0:	f8c1 e184 	str.w	lr, [r1, #388]	; 0x184
 * @note	Do not use for clock pins (SFSCLK0 .. SFSCLK4). Use
 * Chip_SCU_ClockPinMux() function for SFSCLKx clock pins.
 */
STATIC INLINE void Chip_SCU_PinMuxSet(uint8_t port, uint8_t pin, uint16_t modefunc)
{
	LPC_SCU->SFSP[port][pin] = modefunc;
1a0005c4:	f8c2 6098 	str.w	r6, [r2, #152]	; 0x98
1a0005c8:	f242 0604 	movw	r6, #8196	; 0x2004
1a0005cc:	59b8      	ldr	r0, [r7, r6]
1a0005ce:	f420 7000 	bic.w	r0, r0, #512	; 0x200
1a0005d2:	51b8      	str	r0, [r7, r6]
 */
STATIC INLINE void Chip_SCU_GPIOIntPinSel(uint8_t PortSel, uint8_t PortNum, uint8_t PinNum)
{
	int32_t of = (PortSel & 3) << 3;
	uint32_t val = (((PortNum & 0x7) << 5) | (PinNum & 0x1F)) << of;
	LPC_SCU->PINTSEL[PortSel >> 2] = (LPC_SCU->PINTSEL[PortSel >> 2] & ~(0xFF << of)) | val;
1a0005d4:	f8d2 0e00 	ldr.w	r0, [r2, #3584]	; 0xe00
1a0005d8:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
1a0005dc:	f040 5024 	orr.w	r0, r0, #687865856	; 0x29000000
1a0005e0:	f8c2 0e00 	str.w	r0, [r2, #3584]	; 0xe00
 * @param	pins	: Pin interrupts to clear (ORed value of PININTCH*)
 * @return	Nothing
 */
STATIC INLINE void Chip_PININT_ClearIntStatus(LPC_PIN_INT_T *pPININT, uint32_t pins)
{
	pPININT->IST = pins;
1a0005e4:	2208      	movs	r2, #8
1a0005e6:	625a      	str	r2, [r3, #36]	; 0x24
 * @param	pins	: Pins (ORed value of PININTCH*)
 * @return	Nothing
 */
STATIC INLINE void Chip_PININT_SetPinModeEdge(LPC_PIN_INT_T *pPININT, uint32_t pins)
{
	pPININT->ISEL &= ~pins;
1a0005e8:	6818      	ldr	r0, [r3, #0]
1a0005ea:	f020 0008 	bic.w	r0, r0, #8
1a0005ee:	6018      	str	r0, [r3, #0]
 * @param	pins	: Pins to enable (ORed value of PININTCH*)
 * @return	Nothing
 */
STATIC INLINE void Chip_PININT_EnableIntLow(LPC_PIN_INT_T *pPININT, uint32_t pins)
{
	pPININT->SIENF = pins;
1a0005f0:	615a      	str	r2, [r3, #20]
1a0005f2:	f8c1 2184 	str.w	r2, [r1, #388]	; 0x184
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
1a0005f6:	604d      	str	r5, [r1, #4]
1a0005f8:	604c      	str	r4, [r1, #4]
1a0005fa:	f8c1 e004 	str.w	lr, [r1, #4]
1a0005fe:	604a      	str	r2, [r1, #4]
1a000600:	bdf0      	pop	{r4, r5, r6, r7, pc}
1a000602:	bf00      	nop
1a000604:	40086000 	.word	0x40086000
1a000608:	400f4000 	.word	0x400f4000
1a00060c:	40087000 	.word	0x40087000
1a000610:	e000e100 	.word	0xe000e100

1a000614 <GPIO0_IRQHandler>:
 * @param	pins	: Pin interrupts to clear (ORed value of PININTCH*)
 * @return	Nothing
 */
STATIC INLINE void Chip_PININT_ClearIntStatus(LPC_PIN_INT_T *pPININT, uint32_t pins)
{
	pPININT->IST = pins;
1a000614:	2201      	movs	r2, #1
1a000616:	4b04      	ldr	r3, [pc, #16]	; (1a000628 <GPIO0_IRQHandler+0x14>)
1a000618:	625a      	str	r2, [r3, #36]	; 0x24
void GPIO0_IRQHandler (void)
{
	/*Clear interrupt*/
	Chip_PININT_ClearIntStatus(LPC_GPIO_PIN_INT, PININTCH(0));

	presionadas = presionadas | (1<<0);
1a00061a:	4a04      	ldr	r2, [pc, #16]	; (1a00062c <GPIO0_IRQHandler+0x18>)
1a00061c:	7813      	ldrb	r3, [r2, #0]
1a00061e:	f043 0301 	orr.w	r3, r3, #1
1a000622:	7013      	strb	r3, [r2, #0]
1a000624:	4770      	bx	lr
1a000626:	bf00      	nop
1a000628:	40087000 	.word	0x40087000
1a00062c:	1000009c 	.word	0x1000009c

1a000630 <GPIO1_IRQHandler>:
1a000630:	2202      	movs	r2, #2
1a000632:	4b04      	ldr	r3, [pc, #16]	; (1a000644 <GPIO1_IRQHandler+0x14>)
1a000634:	625a      	str	r2, [r3, #36]	; 0x24
void GPIO1_IRQHandler (void)
{
	/*Clear interrupt*/
	Chip_PININT_ClearIntStatus(LPC_GPIO_PIN_INT, PININTCH(1));
	
	presionadas = presionadas | (1<<1);
1a000636:	4a04      	ldr	r2, [pc, #16]	; (1a000648 <GPIO1_IRQHandler+0x18>)
1a000638:	7813      	ldrb	r3, [r2, #0]
1a00063a:	f043 0302 	orr.w	r3, r3, #2
1a00063e:	7013      	strb	r3, [r2, #0]
1a000640:	4770      	bx	lr
1a000642:	bf00      	nop
1a000644:	40087000 	.word	0x40087000
1a000648:	1000009c 	.word	0x1000009c

1a00064c <GPIO2_IRQHandler>:
1a00064c:	2204      	movs	r2, #4
1a00064e:	4b04      	ldr	r3, [pc, #16]	; (1a000660 <GPIO2_IRQHandler+0x14>)
1a000650:	625a      	str	r2, [r3, #36]	; 0x24
//TEC3
void GPIO2_IRQHandler(void){
	/*Clear interrupt*/
	Chip_PININT_ClearIntStatus(LPC_GPIO_PIN_INT, PININTCH(2));
	
	presionadas = presionadas | (1<<2);
1a000652:	4a04      	ldr	r2, [pc, #16]	; (1a000664 <GPIO2_IRQHandler+0x18>)
1a000654:	7813      	ldrb	r3, [r2, #0]
1a000656:	f043 0304 	orr.w	r3, r3, #4
1a00065a:	7013      	strb	r3, [r2, #0]
1a00065c:	4770      	bx	lr
1a00065e:	bf00      	nop
1a000660:	40087000 	.word	0x40087000
1a000664:	1000009c 	.word	0x1000009c

1a000668 <GPIO3_IRQHandler>:
1a000668:	2208      	movs	r2, #8
1a00066a:	4b04      	ldr	r3, [pc, #16]	; (1a00067c <GPIO3_IRQHandler+0x14>)
1a00066c:	625a      	str	r2, [r3, #36]	; 0x24
//TEC4
void GPIO3_IRQHandler(void){
	/*Clear interrupt*/
	Chip_PININT_ClearIntStatus(LPC_GPIO_PIN_INT, PININTCH(3));
	
	presionadas = presionadas | (1<<3);
1a00066e:	4a04      	ldr	r2, [pc, #16]	; (1a000680 <GPIO3_IRQHandler+0x18>)
1a000670:	7813      	ldrb	r3, [r2, #0]
1a000672:	f043 0308 	orr.w	r3, r3, #8
1a000676:	7013      	strb	r3, [r2, #0]
1a000678:	4770      	bx	lr
1a00067a:	bf00      	nop
1a00067c:	40087000 	.word	0x40087000
1a000680:	1000009c 	.word	0x1000009c

1a000684 <Keyboard_init>:
	USBD_HID_INIT_PARAM_T hid_param;
	USB_HID_REPORT_T reports_data[1];
	ErrorCode_t ret = LPC_OK;

	/* Do a quick check of if the interface descriptor passed is the right one. */
	if ((pIntfDesc == 0) || (pIntfDesc->bInterfaceClass != USB_DEVICE_CLASS_HUMAN_INTERFACE)) {
1a000684:	2900      	cmp	r1, #0
1a000686:	d040      	beq.n	1a00070a <Keyboard_init+0x86>
//HID keyboard init routine
ErrorCode_t Keyboard_init(USBD_HANDLE_T hUsb,
						  USB_INTERFACE_DESCRIPTOR *pIntfDesc,
						  uint32_t *mem_base,
						  uint32_t *mem_size)
{
1a000688:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
1a00068c:	b090      	sub	sp, #64	; 0x40
1a00068e:	460c      	mov	r4, r1
	USBD_HID_INIT_PARAM_T hid_param;
	USB_HID_REPORT_T reports_data[1];
	ErrorCode_t ret = LPC_OK;

	/* Do a quick check of if the interface descriptor passed is the right one. */
	if ((pIntfDesc == 0) || (pIntfDesc->bInterfaceClass != USB_DEVICE_CLASS_HUMAN_INTERFACE)) {
1a000690:	7949      	ldrb	r1, [r1, #5]
1a000692:	2903      	cmp	r1, #3
1a000694:	d13c      	bne.n	1a000710 <Keyboard_init+0x8c>
1a000696:	4625      	mov	r5, r4
1a000698:	4698      	mov	r8, r3
1a00069a:	4617      	mov	r7, r2
1a00069c:	4606      	mov	r6, r0
		return ERR_FAILED;
	}

	/* init joystick control */
	Buttons_Init();
1a00069e:	f7ff ff3d 	bl	1a00051c <Buttons_Init>
	Chip_GPIO_Init(LPC_GPIO_PORT);
1a0006a2:	481e      	ldr	r0, [pc, #120]	; (1a00071c <Keyboard_init+0x98>)
1a0006a4:	f000 fed8 	bl	1a001458 <Chip_GPIO_Init>

	/* Init HID params */
	memset((void *) &hid_param, 0, sizeof(USBD_HID_INIT_PARAM_T));
1a0006a8:	2400      	movs	r4, #0
1a0006aa:	9404      	str	r4, [sp, #16]
1a0006ac:	9409      	str	r4, [sp, #36]	; 0x24
1a0006ae:	940a      	str	r4, [sp, #40]	; 0x28
1a0006b0:	940b      	str	r4, [sp, #44]	; 0x2c
1a0006b2:	940d      	str	r4, [sp, #52]	; 0x34
1a0006b4:	940e      	str	r4, [sp, #56]	; 0x38
1a0006b6:	940f      	str	r4, [sp, #60]	; 0x3c
	hid_param.max_reports = 1;
1a0006b8:	2301      	movs	r3, #1
1a0006ba:	f88d 3010 	strb.w	r3, [sp, #16]
	hid_param.mem_base = *mem_base;
1a0006be:	683b      	ldr	r3, [r7, #0]
1a0006c0:	9302      	str	r3, [sp, #8]
	hid_param.mem_size = *mem_size;
1a0006c2:	f8d8 3000 	ldr.w	r3, [r8]
1a0006c6:	9303      	str	r3, [sp, #12]
	hid_param.intf_desc = (uint8_t *) pIntfDesc;
1a0006c8:	9505      	str	r5, [sp, #20]
	/* user defined functions */
	hid_param.HID_GetReport = Keyboard_GetReport;
1a0006ca:	4b15      	ldr	r3, [pc, #84]	; (1a000720 <Keyboard_init+0x9c>)
1a0006cc:	9307      	str	r3, [sp, #28]
	hid_param.HID_SetReport = Keyboard_SetReport;
1a0006ce:	4b15      	ldr	r3, [pc, #84]	; (1a000724 <Keyboard_init+0xa0>)
1a0006d0:	9308      	str	r3, [sp, #32]
	hid_param.HID_EpIn_Hdlr  = Keyboard_EpIN_Hdlr;
1a0006d2:	4b15      	ldr	r3, [pc, #84]	; (1a000728 <Keyboard_init+0xa4>)
1a0006d4:	930c      	str	r3, [sp, #48]	; 0x30
	/* Init reports_data */
	reports_data[0].len = Keyboard_ReportDescSize;
1a0006d6:	4b15      	ldr	r3, [pc, #84]	; (1a00072c <Keyboard_init+0xa8>)
1a0006d8:	881b      	ldrh	r3, [r3, #0]
1a0006da:	f8ad 3000 	strh.w	r3, [sp]
	reports_data[0].idle_time = 0;
1a0006de:	f88d 4002 	strb.w	r4, [sp, #2]
	reports_data[0].desc = (uint8_t *) &Keyboard_ReportDescriptor[0];
1a0006e2:	4b13      	ldr	r3, [pc, #76]	; (1a000730 <Keyboard_init+0xac>)
1a0006e4:	9301      	str	r3, [sp, #4]
	hid_param.report_data  = reports_data;
1a0006e6:	f8cd d018 	str.w	sp, [sp, #24]

	ret = USBD_API->hid->init(hUsb, &hid_param);
1a0006ea:	4b12      	ldr	r3, [pc, #72]	; (1a000734 <Keyboard_init+0xb0>)
1a0006ec:	681b      	ldr	r3, [r3, #0]
1a0006ee:	691b      	ldr	r3, [r3, #16]
1a0006f0:	685b      	ldr	r3, [r3, #4]
1a0006f2:	4630      	mov	r0, r6
1a0006f4:	a902      	add	r1, sp, #8
1a0006f6:	4798      	blx	r3
	/* update memory variables */
	*mem_base = hid_param.mem_base;
1a0006f8:	9b02      	ldr	r3, [sp, #8]
1a0006fa:	603b      	str	r3, [r7, #0]
	*mem_size = hid_param.mem_size;
1a0006fc:	9b03      	ldr	r3, [sp, #12]
1a0006fe:	f8c8 3000 	str.w	r3, [r8]
	/* store stack handle for later use. */
	g_keyBoard.hUsb = hUsb;
1a000702:	4b0d      	ldr	r3, [pc, #52]	; (1a000738 <Keyboard_init+0xb4>)
1a000704:	601e      	str	r6, [r3, #0]
	g_keyBoard.tx_busy = 0;
1a000706:	731c      	strb	r4, [r3, #12]

	return ret;
1a000708:	e004      	b.n	1a000714 <Keyboard_init+0x90>
	USB_HID_REPORT_T reports_data[1];
	ErrorCode_t ret = LPC_OK;

	/* Do a quick check of if the interface descriptor passed is the right one. */
	if ((pIntfDesc == 0) || (pIntfDesc->bInterfaceClass != USB_DEVICE_CLASS_HUMAN_INTERFACE)) {
		return ERR_FAILED;
1a00070a:	f04f 30ff 	mov.w	r0, #4294967295
	/* store stack handle for later use. */
	g_keyBoard.hUsb = hUsb;
	g_keyBoard.tx_busy = 0;

	return ret;
}
1a00070e:	4770      	bx	lr
	USB_HID_REPORT_T reports_data[1];
	ErrorCode_t ret = LPC_OK;

	/* Do a quick check of if the interface descriptor passed is the right one. */
	if ((pIntfDesc == 0) || (pIntfDesc->bInterfaceClass != USB_DEVICE_CLASS_HUMAN_INTERFACE)) {
		return ERR_FAILED;
1a000710:	f04f 30ff 	mov.w	r0, #4294967295
	/* store stack handle for later use. */
	g_keyBoard.hUsb = hUsb;
	g_keyBoard.tx_busy = 0;

	return ret;
}
1a000714:	b010      	add	sp, #64	; 0x40
1a000716:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
1a00071a:	bf00      	nop
1a00071c:	400f4000 	.word	0x400f4000
1a000720:	1a0004e5 	.word	0x1a0004e5
1a000724:	1a0004a1 	.word	0x1a0004a1
1a000728:	1a00041d 	.word	0x1a00041d
1a00072c:	1a001bca 	.word	0x1a001bca
1a000730:	1a001c48 	.word	0x1a001c48
1a000734:	100000a8 	.word	0x100000a8
1a000738:	1000008c 	.word	0x1000008c

1a00073c <Keyboard_Tasks>:

//Keyboard tasks
void Keyboard_Tasks(void)
{
1a00073c:	b538      	push	{r3, r4, r5, lr}
	/* REVISAR QUE EL DISPOSITIVO EST CONFIGURADO ANTES DE ENVIAR DARTOS. */
	if ( USB_IsConfigured(g_keyBoard.hUsb)) {
1a00073e:	4b0e      	ldr	r3, [pc, #56]	; (1a000778 <Keyboard_Tasks+0x3c>)
1a000740:	681b      	ldr	r3, [r3, #0]
}

static INLINE bool USB_IsConfigured(USBD_HANDLE_T hUsb)
{
    USB_CORE_CTRL_T* pCtrl = (USB_CORE_CTRL_T*) hUsb;
    return (bool) (pCtrl->config_value != 0);   
1a000742:	f893 30fd 	ldrb.w	r3, [r3, #253]	; 0xfd
1a000746:	b193      	cbz	r3, 1a00076e <Keyboard_Tasks+0x32>
		/* enviar el reporte */
		if (g_keyBoard.tx_busy == 0) {
1a000748:	4b0b      	ldr	r3, [pc, #44]	; (1a000778 <Keyboard_Tasks+0x3c>)
1a00074a:	7b1b      	ldrb	r3, [r3, #12]
1a00074c:	b993      	cbnz	r3, 1a000774 <Keyboard_Tasks+0x38>
			g_keyBoard.tx_busy = 1;
1a00074e:	4c0a      	ldr	r4, [pc, #40]	; (1a000778 <Keyboard_Tasks+0x3c>)
1a000750:	2301      	movs	r3, #1
1a000752:	7323      	strb	r3, [r4, #12]
			Keyboard_UpdateReport();
1a000754:	f7ff fe6c 	bl	1a000430 <Keyboard_UpdateReport>
			USBD_API->hw->WriteEP(g_keyBoard.hUsb, HID_EP_IN, &g_keyBoard.report[0], KEYBOARD_REPORT_SIZE);
1a000758:	4b08      	ldr	r3, [pc, #32]	; (1a00077c <Keyboard_Tasks+0x40>)
1a00075a:	681b      	ldr	r3, [r3, #0]
1a00075c:	681b      	ldr	r3, [r3, #0]
1a00075e:	6d1d      	ldr	r5, [r3, #80]	; 0x50
1a000760:	4622      	mov	r2, r4
1a000762:	f852 0b04 	ldr.w	r0, [r2], #4
1a000766:	2181      	movs	r1, #129	; 0x81
1a000768:	2308      	movs	r3, #8
1a00076a:	47a8      	blx	r5
1a00076c:	bd38      	pop	{r3, r4, r5, pc}
		}
	}
	else {
		/* resetear bandera si nos desconectamos. */
		g_keyBoard.tx_busy = 0;
1a00076e:	2200      	movs	r2, #0
1a000770:	4b01      	ldr	r3, [pc, #4]	; (1a000778 <Keyboard_Tasks+0x3c>)
1a000772:	731a      	strb	r2, [r3, #12]
1a000774:	bd38      	pop	{r3, r4, r5, pc}
1a000776:	bf00      	nop
1a000778:	1000008c 	.word	0x1000008c
1a00077c:	100000a8 	.word	0x100000a8

1a000780 <initialise_monitor_handles>:
WEAK void SysTick_Handler(void);

WEAK void initialise_monitor_handles(void);

void initialise_monitor_handles(void)
{
1a000780:	4770      	bx	lr
1a000782:	bf00      	nop

1a000784 <Reset_Handler>:
extern unsigned int __data_section_table_end;
extern unsigned int __bss_section_table;
extern unsigned int __bss_section_table_end;

void Reset_Handler(void) {
    __asm__ volatile("cpsid i");
1a000784:	b672      	cpsid	i

    volatile unsigned int *RESET_CONTROL = (unsigned int *) 0x40053100;
    *(RESET_CONTROL + 0) = 0x10DF1000;
1a000786:	4a1a      	ldr	r2, [pc, #104]	; (1a0007f0 <Reset_Handler+0x6c>)
1a000788:	4b1a      	ldr	r3, [pc, #104]	; (1a0007f4 <Reset_Handler+0x70>)
1a00078a:	601a      	str	r2, [r3, #0]
    *(RESET_CONTROL + 1) = 0x01DFF7FF;
1a00078c:	4a1a      	ldr	r2, [pc, #104]	; (1a0007f8 <Reset_Handler+0x74>)
1a00078e:	3304      	adds	r3, #4
1a000790:	601a      	str	r2, [r3, #0]

    volatile unsigned int *NVIC_ICPR = (unsigned int *) 0xE000E280;
    unsigned int irqpendloop;
    for (irqpendloop = 0; irqpendloop < 8; irqpendloop++) {
1a000792:	2300      	movs	r3, #0
1a000794:	e005      	b.n	1a0007a2 <Reset_Handler+0x1e>
        *(NVIC_ICPR + irqpendloop) = 0xFFFFFFFF;
1a000796:	f04f 31ff 	mov.w	r1, #4294967295
1a00079a:	4a18      	ldr	r2, [pc, #96]	; (1a0007fc <Reset_Handler+0x78>)
1a00079c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    *(RESET_CONTROL + 0) = 0x10DF1000;
    *(RESET_CONTROL + 1) = 0x01DFF7FF;

    volatile unsigned int *NVIC_ICPR = (unsigned int *) 0xE000E280;
    unsigned int irqpendloop;
    for (irqpendloop = 0; irqpendloop < 8; irqpendloop++) {
1a0007a0:	3301      	adds	r3, #1
1a0007a2:	2b07      	cmp	r3, #7
1a0007a4:	d9f7      	bls.n	1a000796 <Reset_Handler+0x12>
extern unsigned int __data_section_table;
extern unsigned int __data_section_table_end;
extern unsigned int __bss_section_table;
extern unsigned int __bss_section_table_end;

void Reset_Handler(void) {
1a0007a6:	b510      	push	{r4, lr}
    volatile unsigned int *NVIC_ICPR = (unsigned int *) 0xE000E280;
    unsigned int irqpendloop;
    for (irqpendloop = 0; irqpendloop < 8; irqpendloop++) {
        *(NVIC_ICPR + irqpendloop) = 0xFFFFFFFF;
    }
    __asm__ volatile("cpsie i");
1a0007a8:	b662      	cpsie	i

    unsigned int LoadAddr, ExeAddr, SectionLen;
    unsigned int *SectionTableAddr;

    SectionTableAddr = &__data_section_table;
1a0007aa:	4b15      	ldr	r3, [pc, #84]	; (1a000800 <Reset_Handler+0x7c>)
    while (SectionTableAddr < &__data_section_table_end) {
1a0007ac:	e007      	b.n	1a0007be <Reset_Handler+0x3a>
        LoadAddr = *SectionTableAddr++;
        ExeAddr = *SectionTableAddr++;
        SectionLen = *SectionTableAddr++;
1a0007ae:	f103 040c 	add.w	r4, r3, #12
        data_init(LoadAddr, ExeAddr, SectionLen);
1a0007b2:	6818      	ldr	r0, [r3, #0]
1a0007b4:	6859      	ldr	r1, [r3, #4]
1a0007b6:	689a      	ldr	r2, [r3, #8]
1a0007b8:	f7ff fcf0 	bl	1a00019c <data_init>

    SectionTableAddr = &__data_section_table;
    while (SectionTableAddr < &__data_section_table_end) {
        LoadAddr = *SectionTableAddr++;
        ExeAddr = *SectionTableAddr++;
        SectionLen = *SectionTableAddr++;
1a0007bc:	4623      	mov	r3, r4

    unsigned int LoadAddr, ExeAddr, SectionLen;
    unsigned int *SectionTableAddr;

    SectionTableAddr = &__data_section_table;
    while (SectionTableAddr < &__data_section_table_end) {
1a0007be:	4a11      	ldr	r2, [pc, #68]	; (1a000804 <Reset_Handler+0x80>)
1a0007c0:	4293      	cmp	r3, r2
1a0007c2:	d3f4      	bcc.n	1a0007ae <Reset_Handler+0x2a>
1a0007c4:	e006      	b.n	1a0007d4 <Reset_Handler+0x50>
        ExeAddr = *SectionTableAddr++;
        SectionLen = *SectionTableAddr++;
        data_init(LoadAddr, ExeAddr, SectionLen);
    }
    while (SectionTableAddr < &__bss_section_table_end) {
        ExeAddr = *SectionTableAddr++;
1a0007c6:	461c      	mov	r4, r3
        SectionLen = *SectionTableAddr++;
        bss_init(ExeAddr, SectionLen);
1a0007c8:	f854 0b08 	ldr.w	r0, [r4], #8
1a0007cc:	6859      	ldr	r1, [r3, #4]
1a0007ce:	f7ff fcf3 	bl	1a0001b8 <bss_init>
        SectionLen = *SectionTableAddr++;
        data_init(LoadAddr, ExeAddr, SectionLen);
    }
    while (SectionTableAddr < &__bss_section_table_end) {
        ExeAddr = *SectionTableAddr++;
        SectionLen = *SectionTableAddr++;
1a0007d2:	4623      	mov	r3, r4
        LoadAddr = *SectionTableAddr++;
        ExeAddr = *SectionTableAddr++;
        SectionLen = *SectionTableAddr++;
        data_init(LoadAddr, ExeAddr, SectionLen);
    }
    while (SectionTableAddr < &__bss_section_table_end) {
1a0007d4:	4a0c      	ldr	r2, [pc, #48]	; (1a000808 <Reset_Handler+0x84>)
1a0007d6:	4293      	cmp	r3, r2
1a0007d8:	d3f5      	bcc.n	1a0007c6 <Reset_Handler+0x42>
        ExeAddr = *SectionTableAddr++;
        SectionLen = *SectionTableAddr++;
        bss_init(ExeAddr, SectionLen);
    }

    SystemInit();
1a0007da:	f000 fed5 	bl	1a001588 <SystemInit>

    __libc_init_array();
1a0007de:	f001 f9c1 	bl	1a001b64 <__libc_init_array>
    initialise_monitor_handles();
1a0007e2:	f7ff ffcd 	bl	1a000780 <initialise_monitor_handles>
    main();
1a0007e6:	f7ff fdb5 	bl	1a000354 <main>
    while (1) {
        __asm__ volatile("wfi");
1a0007ea:	bf30      	wfi
    }
1a0007ec:	e7fd      	b.n	1a0007ea <Reset_Handler+0x66>
1a0007ee:	bf00      	nop
1a0007f0:	10df1000 	.word	0x10df1000
1a0007f4:	40053100 	.word	0x40053100
1a0007f8:	01dff7ff 	.word	0x01dff7ff
1a0007fc:	e000e280 	.word	0xe000e280
1a000800:	1a000114 	.word	0x1a000114
1a000804:	1a000150 	.word	0x1a000150
1a000808:	1a000178 	.word	0x1a000178

1a00080c <_fini>:
    for (loop = 0; loop < len; loop = loop + 4)
        *pulDest++ = 0;
}

WEAK void _fini(void);
void _fini(void) {}
1a00080c:	4770      	bx	lr
1a00080e:	bf00      	nop

1a000810 <_init>:

WEAK void _init(void);
void _init(void) {}
1a000810:	4770      	bx	lr
1a000812:	bf00      	nop

1a000814 <Board_LED_Init>:
#define GPIO_BUTTONS_SIZE   (sizeof(GpioButtons) / sizeof(struct gpio_t))
#define GPIO_PORTS_SIZE     (sizeof(GpioPorts) / sizeof(struct gpio_t))


static void Board_LED_Init()
{
1a000814:	b470      	push	{r4, r5, r6}
    for (uint32_t i = 0; i < GPIO_LEDS_SIZE; ++i) {
1a000816:	2200      	movs	r2, #0
1a000818:	e014      	b.n	1a000844 <Board_LED_Init+0x30>
        const struct gpio_t *io = &GpioLeds[i];
        Chip_GPIO_SetPinDIROutput(LPC_GPIO_PORT, io->port, io->pin);
1a00081a:	4b0c      	ldr	r3, [pc, #48]	; (1a00084c <Board_LED_Init+0x38>)
1a00081c:	f813 4012 	ldrb.w	r4, [r3, r2, lsl #1]
1a000820:	eb03 0342 	add.w	r3, r3, r2, lsl #1
1a000824:	7859      	ldrb	r1, [r3, #1]
 * @param	pin		: GPIO pin to set direction on as output
 * @return	Nothing
 */
STATIC INLINE void Chip_GPIO_SetPinDIROutput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
{
	pGPIO->DIR[port] |= 1UL << pin;
1a000826:	480a      	ldr	r0, [pc, #40]	; (1a000850 <Board_LED_Init+0x3c>)
1a000828:	f504 6500 	add.w	r5, r4, #2048	; 0x800
1a00082c:	f850 6025 	ldr.w	r6, [r0, r5, lsl #2]
1a000830:	2301      	movs	r3, #1
1a000832:	408b      	lsls	r3, r1
1a000834:	4333      	orrs	r3, r6
1a000836:	f840 3025 	str.w	r3, [r0, r5, lsl #2]
 * @return	Nothing
 * @note	This function replaces Chip_GPIO_WritePortBit()
 */
STATIC INLINE void Chip_GPIO_SetPinState(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin, bool setting)
{
	pGPIO->B[port][pin] = setting;
1a00083a:	eb01 1144 	add.w	r1, r1, r4, lsl #5
1a00083e:	2300      	movs	r3, #0
1a000840:	5443      	strb	r3, [r0, r1]
#define GPIO_PORTS_SIZE     (sizeof(GpioPorts) / sizeof(struct gpio_t))


static void Board_LED_Init()
{
    for (uint32_t i = 0; i < GPIO_LEDS_SIZE; ++i) {
1a000842:	3201      	adds	r2, #1
1a000844:	2a05      	cmp	r2, #5
1a000846:	d9e8      	bls.n	1a00081a <Board_LED_Init+0x6>
        const struct gpio_t *io = &GpioLeds[i];
        Chip_GPIO_SetPinDIROutput(LPC_GPIO_PORT, io->port, io->pin);
        Chip_GPIO_SetPinState(LPC_GPIO_PORT, io->port, io->pin, false);
    }
}
1a000848:	bc70      	pop	{r4, r5, r6}
1a00084a:	4770      	bx	lr
1a00084c:	1a001cc0 	.word	0x1a001cc0
1a000850:	400f4000 	.word	0x400f4000

1a000854 <Board_TEC_Init>:


static void Board_TEC_Init()
{
1a000854:	b430      	push	{r4, r5}
    for (uint32_t i = 0; i < GPIO_BUTTONS_SIZE; ++i) {
1a000856:	2300      	movs	r3, #0
1a000858:	e011      	b.n	1a00087e <Board_TEC_Init+0x2a>
        const struct gpio_t *io = &GpioButtons[i];
        Chip_GPIO_SetPinDIRInput(LPC_GPIO_PORT, io->port, io->pin);
1a00085a:	490b      	ldr	r1, [pc, #44]	; (1a000888 <Board_TEC_Init+0x34>)
1a00085c:	f811 2013 	ldrb.w	r2, [r1, r3, lsl #1]
1a000860:	eb01 0143 	add.w	r1, r1, r3, lsl #1
1a000864:	784d      	ldrb	r5, [r1, #1]
 * @param	pin		: GPIO pin to set direction on as input
 * @return	Nothing
 */
STATIC INLINE void Chip_GPIO_SetPinDIRInput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
{
	pGPIO->DIR[port] &= ~(1UL << pin);
1a000866:	4c09      	ldr	r4, [pc, #36]	; (1a00088c <Board_TEC_Init+0x38>)
1a000868:	f502 6200 	add.w	r2, r2, #2048	; 0x800
1a00086c:	f854 0022 	ldr.w	r0, [r4, r2, lsl #2]
1a000870:	2101      	movs	r1, #1
1a000872:	40a9      	lsls	r1, r5
1a000874:	ea20 0101 	bic.w	r1, r0, r1
1a000878:	f844 1022 	str.w	r1, [r4, r2, lsl #2]
}


static void Board_TEC_Init()
{
    for (uint32_t i = 0; i < GPIO_BUTTONS_SIZE; ++i) {
1a00087c:	3301      	adds	r3, #1
1a00087e:	2b03      	cmp	r3, #3
1a000880:	d9eb      	bls.n	1a00085a <Board_TEC_Init+0x6>
        const struct gpio_t *io = &GpioButtons[i];
        Chip_GPIO_SetPinDIRInput(LPC_GPIO_PORT, io->port, io->pin);
    }
}
1a000882:	bc30      	pop	{r4, r5}
1a000884:	4770      	bx	lr
1a000886:	bf00      	nop
1a000888:	1a001cb8 	.word	0x1a001cb8
1a00088c:	400f4000 	.word	0x400f4000

1a000890 <Board_GPIO_Init>:


static void Board_GPIO_Init()
{
1a000890:	b430      	push	{r4, r5}
    for (uint32_t i = 0; i < GPIO_PORTS_SIZE; ++i) {
1a000892:	2300      	movs	r3, #0
1a000894:	e011      	b.n	1a0008ba <Board_GPIO_Init+0x2a>
        const struct gpio_t *io = &GpioPorts[i];
        Chip_GPIO_SetPinDIRInput(LPC_GPIO_PORT, io->port, io->pin);
1a000896:	490b      	ldr	r1, [pc, #44]	; (1a0008c4 <Board_GPIO_Init+0x34>)
1a000898:	f811 2013 	ldrb.w	r2, [r1, r3, lsl #1]
1a00089c:	eb01 0143 	add.w	r1, r1, r3, lsl #1
1a0008a0:	784d      	ldrb	r5, [r1, #1]
1a0008a2:	4c09      	ldr	r4, [pc, #36]	; (1a0008c8 <Board_GPIO_Init+0x38>)
1a0008a4:	f502 6200 	add.w	r2, r2, #2048	; 0x800
1a0008a8:	f854 0022 	ldr.w	r0, [r4, r2, lsl #2]
1a0008ac:	2101      	movs	r1, #1
1a0008ae:	40a9      	lsls	r1, r5
1a0008b0:	ea20 0101 	bic.w	r1, r0, r1
1a0008b4:	f844 1022 	str.w	r1, [r4, r2, lsl #2]
}


static void Board_GPIO_Init()
{
    for (uint32_t i = 0; i < GPIO_PORTS_SIZE; ++i) {
1a0008b8:	3301      	adds	r3, #1
1a0008ba:	2b08      	cmp	r3, #8
1a0008bc:	d9eb      	bls.n	1a000896 <Board_GPIO_Init+0x6>
        const struct gpio_t *io = &GpioPorts[i];
        Chip_GPIO_SetPinDIRInput(LPC_GPIO_PORT, io->port, io->pin);
    }
}
1a0008be:	bc30      	pop	{r4, r5}
1a0008c0:	4770      	bx	lr
1a0008c2:	bf00      	nop
1a0008c4:	1a001c9c 	.word	0x1a001c9c
1a0008c8:	400f4000 	.word	0x400f4000

1a0008cc <Board_ADC_Init>:
    Chip_SSP_Enable(LPC_SSP1);
}


static void Board_ADC_Init()
{
1a0008cc:	b510      	push	{r4, lr}
1a0008ce:	b082      	sub	sp, #8
    ADC_CLOCK_SETUP_T cs;

    Chip_ADC_Init(LPC_ADC0, &cs);
1a0008d0:	4c08      	ldr	r4, [pc, #32]	; (1a0008f4 <Board_ADC_Init+0x28>)
1a0008d2:	4620      	mov	r0, r4
1a0008d4:	4669      	mov	r1, sp
1a0008d6:	f000 f9a7 	bl	1a000c28 <Chip_ADC_Init>
    Chip_ADC_SetSampleRate(LPC_ADC0, &cs, BOARD_ADC_SAMPLE_RATE);
1a0008da:	4620      	mov	r0, r4
1a0008dc:	4669      	mov	r1, sp
1a0008de:	4a06      	ldr	r2, [pc, #24]	; (1a0008f8 <Board_ADC_Init+0x2c>)
1a0008e0:	f000 f9c2 	bl	1a000c68 <Chip_ADC_SetSampleRate>
    Chip_ADC_SetResolution(LPC_ADC0, &cs, BOARD_ADC_RESOLUTION);
1a0008e4:	4620      	mov	r0, r4
1a0008e6:	4669      	mov	r1, sp
1a0008e8:	2200      	movs	r2, #0
1a0008ea:	f000 f9d7 	bl	1a000c9c <Chip_ADC_SetResolution>
}
1a0008ee:	b002      	add	sp, #8
1a0008f0:	bd10      	pop	{r4, pc}
1a0008f2:	bf00      	nop
1a0008f4:	400e3000 	.word	0x400e3000
1a0008f8:	00061a80 	.word	0x00061a80

1a0008fc <Board_SPI_Init>:
    Chip_I2C_SetClockRate(I2C0, BOARD_I2C_SPEED);
}


static void Board_SPI_Init()
{
1a0008fc:	b510      	push	{r4, lr}
    Chip_SSP_Init(LPC_SSP1);
1a0008fe:	4c0b      	ldr	r4, [pc, #44]	; (1a00092c <Board_SPI_Init+0x30>)
1a000900:	4620      	mov	r0, r4
1a000902:	f000 fdeb 	bl	1a0014dc <Chip_SSP_Init>
 *						- SSP_MODE_SLAVE
 * @return	 Nothing
 */
STATIC INLINE void Chip_SSP_Set_Mode(LPC_SSP_T *pSSP, uint32_t mode)
{
	pSSP->CR1 = (pSSP->CR1 & ~(1 << 2)) | mode;
1a000906:	6863      	ldr	r3, [r4, #4]
1a000908:	f023 0304 	bic.w	r3, r3, #4
1a00090c:	6063      	str	r3, [r4, #4]
 * @return	 Nothing
 * @note	Note: The clockFormat is only used in SPI mode
 */
STATIC INLINE void Chip_SSP_SetFormat(LPC_SSP_T *pSSP, uint32_t bits, uint32_t frameFormat, uint32_t clockMode)
{
	pSSP->CR0 = (pSSP->CR0 & ~0xFF) | bits | frameFormat | clockMode;
1a00090e:	6823      	ldr	r3, [r4, #0]
1a000910:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
1a000914:	f043 0307 	orr.w	r3, r3, #7
1a000918:	6023      	str	r3, [r4, #0]
    Chip_SSP_Set_Mode(LPC_SSP1, BOARD_SPI_MODE);
    Chip_SSP_SetFormat(LPC_SSP1, BOARD_SPI_BITS, BOARD_SPI_FORMAT,
                       BOARD_SPI_POLARITY);
    Chip_SSP_SetBitRate(LPC_SSP1, BOARD_SPI_SPEED);
1a00091a:	4620      	mov	r0, r4
1a00091c:	4904      	ldr	r1, [pc, #16]	; (1a000930 <Board_SPI_Init+0x34>)
1a00091e:	f000 fdbd 	bl	1a00149c <Chip_SSP_SetBitRate>
 * @param	pSSP		: The base of SSP peripheral on the chip
 * @return	 Nothing
 */
STATIC INLINE void Chip_SSP_Enable(LPC_SSP_T *pSSP)
{
	pSSP->CR1 |= SSP_CR1_SSP_EN;
1a000922:	6863      	ldr	r3, [r4, #4]
1a000924:	f043 0302 	orr.w	r3, r3, #2
1a000928:	6063      	str	r3, [r4, #4]
1a00092a:	bd10      	pop	{r4, pc}
1a00092c:	400c5000 	.word	0x400c5000
1a000930:	000186a0 	.word	0x000186a0

1a000934 <Board_I2C_Init>:
    }
}


static void Board_I2C_Init()
{
1a000934:	b508      	push	{r3, lr}
    Chip_I2C_Init(I2C0);
1a000936:	2000      	movs	r0, #0
1a000938:	f000 fdfc 	bl	1a001534 <Chip_I2C_Init>
 *                  - I2C0_FAST_MODE_PLUS: Fast-mode Plus transmit
 * @return	Nothing
 */
STATIC INLINE void Chip_SCU_I2C0PinConfig(uint32_t I2C0Mode)
{
	LPC_SCU->SFSI2C0 = I2C0Mode;
1a00093c:	f640 0208 	movw	r2, #2056	; 0x808
1a000940:	4b03      	ldr	r3, [pc, #12]	; (1a000950 <Board_I2C_Init+0x1c>)
1a000942:	f8c3 2c84 	str.w	r2, [r3, #3204]	; 0xc84
    Chip_SCU_I2C0PinConfig(BOARD_I2C_MODE);
    Chip_I2C_SetClockRate(I2C0, BOARD_I2C_SPEED);
1a000946:	2000      	movs	r0, #0
1a000948:	4902      	ldr	r1, [pc, #8]	; (1a000954 <Board_I2C_Init+0x20>)
1a00094a:	f000 fe05 	bl	1a001558 <Chip_I2C_SetClockRate>
1a00094e:	bd08      	pop	{r3, pc}
1a000950:	40086000 	.word	0x40086000
1a000954:	000f4240 	.word	0x000f4240

1a000958 <Board_Debug_Init>:
    Chip_ADC_SetResolution(LPC_ADC0, &cs, BOARD_ADC_RESOLUTION);
}


void Board_Debug_Init(void)
{
1a000958:	b510      	push	{r4, lr}
    Chip_UART_Init(DEBUG_UART);
1a00095a:	4c07      	ldr	r4, [pc, #28]	; (1a000978 <Board_Debug_Init+0x20>)
1a00095c:	4620      	mov	r0, r4
1a00095e:	f000 f8a5 	bl	1a000aac <Chip_UART_Init>
    Chip_UART_SetBaudFDR(DEBUG_UART, DEBUG_UART_BAUD_RATE);
1a000962:	4620      	mov	r0, r4
1a000964:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
1a000968:	f000 f8ca 	bl	1a000b00 <Chip_UART_SetBaudFDR>
 *			stop bit, and even (enabled) parity would be
 *			(UART_LCR_WLEN8 | UART_LCR_SBS_1BIT | UART_LCR_PARITY_EN | UART_LCR_PARITY_EVEN)
 */
STATIC INLINE void Chip_UART_ConfigData(LPC_USART_T *pUART, uint32_t config)
{
	pUART->LCR = config;
1a00096c:	2303      	movs	r3, #3
1a00096e:	60e3      	str	r3, [r4, #12]
 * @param	pUART	: Pointer to selected pUART peripheral
 * @return Nothing
 */
STATIC INLINE void Chip_UART_TXEnable(LPC_USART_T *pUART)
{
    pUART->TER2 = UART_TER2_TXEN;
1a000970:	2301      	movs	r3, #1
1a000972:	65e3      	str	r3, [r4, #92]	; 0x5c
1a000974:	bd10      	pop	{r4, pc}
1a000976:	bf00      	nop
1a000978:	400c1000 	.word	0x400c1000

1a00097c <Board_LED_Set>:
}


void Board_LED_Set(uint8_t LEDNumber, bool On)
{
    if (LEDNumber >= GPIO_LEDS_SIZE) {
1a00097c:	2805      	cmp	r0, #5
1a00097e:	d809      	bhi.n	1a000994 <Board_LED_Set+0x18>
        return;
    }

    const struct gpio_t *io = &GpioLeds[LEDNumber];
    Chip_GPIO_SetPinState(LPC_GPIO_PORT, io->port, io->pin, On);
1a000980:	4b05      	ldr	r3, [pc, #20]	; (1a000998 <Board_LED_Set+0x1c>)
1a000982:	f813 2010 	ldrb.w	r2, [r3, r0, lsl #1]
1a000986:	eb03 0040 	add.w	r0, r3, r0, lsl #1
1a00098a:	7843      	ldrb	r3, [r0, #1]
 * @return	Nothing
 * @note	This function replaces Chip_GPIO_WritePortBit()
 */
STATIC INLINE void Chip_GPIO_SetPinState(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin, bool setting)
{
	pGPIO->B[port][pin] = setting;
1a00098c:	eb03 1342 	add.w	r3, r3, r2, lsl #5
1a000990:	4a02      	ldr	r2, [pc, #8]	; (1a00099c <Board_LED_Set+0x20>)
1a000992:	54d1      	strb	r1, [r2, r3]
1a000994:	4770      	bx	lr
1a000996:	bf00      	nop
1a000998:	1a001cc0 	.word	0x1a001cc0
1a00099c:	400f4000 	.word	0x400f4000

1a0009a0 <Board_Init>:
    Board_LED_Set(LEDNumber, !Board_LED_Test(LEDNumber));
}


void Board_Init(void)
{
1a0009a0:	b508      	push	{r3, lr}
   DEBUGINIT();
1a0009a2:	f7ff ffd9 	bl	1a000958 <Board_Debug_Init>
   Chip_GPIO_Init (LPC_GPIO_PORT);
1a0009a6:	4808      	ldr	r0, [pc, #32]	; (1a0009c8 <Board_Init+0x28>)
1a0009a8:	f000 fd56 	bl	1a001458 <Chip_GPIO_Init>
   
   Board_GPIO_Init();
1a0009ac:	f7ff ff70 	bl	1a000890 <Board_GPIO_Init>
   Board_ADC_Init();
1a0009b0:	f7ff ff8c 	bl	1a0008cc <Board_ADC_Init>
   Board_SPI_Init();
1a0009b4:	f7ff ffa2 	bl	1a0008fc <Board_SPI_Init>
   Board_I2C_Init();
1a0009b8:	f7ff ffbc 	bl	1a000934 <Board_I2C_Init>

   Board_LED_Init();
1a0009bc:	f7ff ff2a 	bl	1a000814 <Board_LED_Init>
   Board_TEC_Init();
1a0009c0:	f7ff ff48 	bl	1a000854 <Board_TEC_Init>
1a0009c4:	bd08      	pop	{r3, pc}
1a0009c6:	bf00      	nop
1a0009c8:	400f4000 	.word	0x400f4000

1a0009cc <__stdio_init>:

int __stdio_getchar() {
   return Board_UARTGetChar();;
}

void __stdio_init() {
1a0009cc:	b508      	push	{r3, lr}
   Board_Debug_Init();
1a0009ce:	f7ff ffc3 	bl	1a000958 <Board_Debug_Init>
1a0009d2:	bd08      	pop	{r3, pc}

1a0009d4 <Board_SetupMuxing>:
    #endif
};


void Board_SetupMuxing(void)
{
1a0009d4:	b410      	push	{r4}
 * @return	Nothing
 */
STATIC INLINE void Chip_SCU_SetPinMuxing(const PINMUX_GRP_T *pinArray, uint32_t arrayLength)
{
	uint32_t ix;
	for (ix = 0; ix < arrayLength; ix++ ) {
1a0009d6:	2300      	movs	r3, #0
1a0009d8:	e00c      	b.n	1a0009f4 <Board_SetupMuxing+0x20>
		Chip_SCU_PinMuxSet(pinArray[ix].pingrp, pinArray[ix].pinnum, pinArray[ix].modefunc);
1a0009da:	4a09      	ldr	r2, [pc, #36]	; (1a000a00 <Board_SetupMuxing+0x2c>)
1a0009dc:	eb02 0183 	add.w	r1, r2, r3, lsl #2
1a0009e0:	f812 4023 	ldrb.w	r4, [r2, r3, lsl #2]
1a0009e4:	784a      	ldrb	r2, [r1, #1]
1a0009e6:	8848      	ldrh	r0, [r1, #2]
 * @note	Do not use for clock pins (SFSCLK0 .. SFSCLK4). Use
 * Chip_SCU_ClockPinMux() function for SFSCLKx clock pins.
 */
STATIC INLINE void Chip_SCU_PinMuxSet(uint8_t port, uint8_t pin, uint16_t modefunc)
{
	LPC_SCU->SFSP[port][pin] = modefunc;
1a0009e8:	eb02 1244 	add.w	r2, r2, r4, lsl #5
1a0009ec:	4905      	ldr	r1, [pc, #20]	; (1a000a04 <Board_SetupMuxing+0x30>)
1a0009ee:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
 * @return	Nothing
 */
STATIC INLINE void Chip_SCU_SetPinMuxing(const PINMUX_GRP_T *pinArray, uint32_t arrayLength)
{
	uint32_t ix;
	for (ix = 0; ix < arrayLength; ix++ ) {
1a0009f2:	3301      	adds	r3, #1
1a0009f4:	2b1c      	cmp	r3, #28
1a0009f6:	d9f0      	bls.n	1a0009da <Board_SetupMuxing+0x6>
    Chip_SCU_SetPinMuxing(pinmuxing, sizeof(pinmuxing) / sizeof(PINMUX_GRP_T));
}
1a0009f8:	f85d 4b04 	ldr.w	r4, [sp], #4
1a0009fc:	4770      	bx	lr
1a0009fe:	bf00      	nop
1a000a00:	1a001cd0 	.word	0x1a001cd0
1a000a04:	40086000 	.word	0x40086000

1a000a08 <Board_SetupClocking>:


void Board_SetupClocking(void)
{
1a000a08:	b510      	push	{r4, lr}
 */
STATIC INLINE void Chip_CREG_SetFlashAcceleration(uint32_t Hz)
{
	uint32_t FAValue = Hz / 21510000;

	LPC_CREG->FLASHCFGA = (LPC_CREG->FLASHCFGA & (~(0xF << 12))) | (FAValue << 12);
1a000a0a:	4a17      	ldr	r2, [pc, #92]	; (1a000a68 <Board_SetupClocking+0x60>)
1a000a0c:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
1a000a10:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
1a000a14:	f443 4310 	orr.w	r3, r3, #36864	; 0x9000
1a000a18:	f8c2 3120 	str.w	r3, [r2, #288]	; 0x120
	LPC_CREG->FLASHCFGB = (LPC_CREG->FLASHCFGB & (~(0xF << 12))) | (FAValue << 12);
1a000a1c:	f8d2 3124 	ldr.w	r3, [r2, #292]	; 0x124
1a000a20:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
1a000a24:	f443 4310 	orr.w	r3, r3, #36864	; 0x9000
1a000a28:	f8c2 3124 	str.w	r3, [r2, #292]	; 0x124
    Chip_CREG_SetFlashAcceleration(MAX_CLOCK_FREQ);
    Chip_SetupCoreClock(CLKIN_CRYSTAL, MAX_CLOCK_FREQ, true);
1a000a2c:	2006      	movs	r0, #6
1a000a2e:	490f      	ldr	r1, [pc, #60]	; (1a000a6c <Board_SetupClocking+0x64>)
1a000a30:	2201      	movs	r2, #1
1a000a32:	f000 fc69 	bl	1a001308 <Chip_SetupCoreClock>

    /* Setup system base clocks and initial states. This won't enable and
       disable individual clocks, but sets up the base clock sources for
       each individual peripheral clock. */
    for (uint32_t i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); ++i)
1a000a36:	2400      	movs	r4, #0
1a000a38:	e00a      	b.n	1a000a50 <Board_SetupClocking+0x48>
    {
        const struct CLK_BASE_STATES *c = &InitClkStates[i];
        Chip_Clock_SetBaseClock (c->clk, c->clkin, c->autoblock_enab,
1a000a3a:	4a0d      	ldr	r2, [pc, #52]	; (1a000a70 <Board_SetupClocking+0x68>)
1a000a3c:	eb02 0384 	add.w	r3, r2, r4, lsl #2
1a000a40:	f812 0024 	ldrb.w	r0, [r2, r4, lsl #2]
1a000a44:	7859      	ldrb	r1, [r3, #1]
1a000a46:	789a      	ldrb	r2, [r3, #2]
1a000a48:	2301      	movs	r3, #1
1a000a4a:	f000 fb4b 	bl	1a0010e4 <Chip_Clock_SetBaseClock>
    Chip_SetupCoreClock(CLKIN_CRYSTAL, MAX_CLOCK_FREQ, true);

    /* Setup system base clocks and initial states. This won't enable and
       disable individual clocks, but sets up the base clock sources for
       each individual peripheral clock. */
    for (uint32_t i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); ++i)
1a000a4e:	3401      	adds	r4, #1
1a000a50:	2c00      	cmp	r4, #0
1a000a52:	d0f2      	beq.n	1a000a3a <Board_SetupClocking+0x32>
        Chip_Clock_SetBaseClock (c->clk, c->clkin, c->autoblock_enab,
                                c->powerdn);
    }

    /* Reset and enable 32Khz oscillator */
    LPC_CREG->CREG0 &= ~((1 << 3) | (1 << 2));
1a000a54:	4b04      	ldr	r3, [pc, #16]	; (1a000a68 <Board_SetupClocking+0x60>)
1a000a56:	685a      	ldr	r2, [r3, #4]
1a000a58:	f022 020c 	bic.w	r2, r2, #12
1a000a5c:	605a      	str	r2, [r3, #4]
    LPC_CREG->CREG0 |= (1 << 1) | (1 << 0);
1a000a5e:	685a      	ldr	r2, [r3, #4]
1a000a60:	f042 0203 	orr.w	r2, r2, #3
1a000a64:	605a      	str	r2, [r3, #4]
1a000a66:	bd10      	pop	{r4, pc}
1a000a68:	40043000 	.word	0x40043000
1a000a6c:	0c28cb00 	.word	0x0c28cb00
1a000a70:	1a001ccc 	.word	0x1a001ccc

1a000a74 <Board_SystemInit>:
}


/* Set up and initialize hardware prior to call to main */
void Board_SystemInit(void)
{
1a000a74:	b508      	push	{r3, lr}
    /* Setup system clocking and memory. This is done early to allow the
       application and tools to clear memory and use scatter loading to
       external memory. */
    Board_SetupMuxing();
1a000a76:	f7ff ffad 	bl	1a0009d4 <Board_SetupMuxing>
    Board_SetupClocking();
1a000a7a:	f7ff ffc5 	bl	1a000a08 <Board_SetupClocking>
1a000a7e:	bd08      	pop	{r3, pc}

1a000a80 <Chip_UART_GetIndex>:

/* Returns clock index for the peripheral block */
static int Chip_UART_GetIndex(LPC_USART_T *pUART)
{
	uint32_t base = (uint32_t) pUART;
	switch(base) {
1a000a80:	4b09      	ldr	r3, [pc, #36]	; (1a000aa8 <Chip_UART_GetIndex+0x28>)
1a000a82:	4298      	cmp	r0, r3
1a000a84:	d009      	beq.n	1a000a9a <Chip_UART_GetIndex+0x1a>
1a000a86:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
1a000a8a:	4298      	cmp	r0, r3
1a000a8c:	d007      	beq.n	1a000a9e <Chip_UART_GetIndex+0x1e>
1a000a8e:	f5a3 2380 	sub.w	r3, r3, #262144	; 0x40000
1a000a92:	4298      	cmp	r0, r3
1a000a94:	d005      	beq.n	1a000aa2 <Chip_UART_GetIndex+0x22>
		case LPC_USART0_BASE:
			return 0;
1a000a96:	2000      	movs	r0, #0
1a000a98:	4770      	bx	lr
		case LPC_UART1_BASE:
			return 1;
		case LPC_USART2_BASE:
			return 2;
1a000a9a:	2002      	movs	r0, #2
1a000a9c:	4770      	bx	lr
		case LPC_USART3_BASE:
			return 3;
1a000a9e:	2003      	movs	r0, #3
1a000aa0:	4770      	bx	lr
	uint32_t base = (uint32_t) pUART;
	switch(base) {
		case LPC_USART0_BASE:
			return 0;
		case LPC_UART1_BASE:
			return 1;
1a000aa2:	2001      	movs	r0, #1
		case LPC_USART3_BASE:
			return 3;
		default:
			return 0; /* Should never come here */
	}
}
1a000aa4:	4770      	bx	lr
1a000aa6:	bf00      	nop
1a000aa8:	400c1000 	.word	0x400c1000

1a000aac <Chip_UART_Init>:
 * Public functions
 ****************************************************************************/

/* Initializes the pUART peripheral */
void Chip_UART_Init(LPC_USART_T *pUART)
{
1a000aac:	b510      	push	{r4, lr}
1a000aae:	b082      	sub	sp, #8
1a000ab0:	4604      	mov	r4, r0
    volatile uint32_t tmp;

	/* Enable UART clocking. UART base clock(s) must already be enabled */
	Chip_Clock_EnableOpts(UART_PClock[Chip_UART_GetIndex(pUART)], true, true, 1);
1a000ab2:	f7ff ffe5 	bl	1a000a80 <Chip_UART_GetIndex>
1a000ab6:	4b10      	ldr	r3, [pc, #64]	; (1a000af8 <Chip_UART_Init+0x4c>)
1a000ab8:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
1a000abc:	2101      	movs	r1, #1
1a000abe:	460a      	mov	r2, r1
1a000ac0:	460b      	mov	r3, r1
1a000ac2:	f000 fb55 	bl	1a001170 <Chip_Clock_EnableOpts>
 *			with a RX trip level of 8 characters, use something like
 *			(UART_FCR_FIFO_EN | UART_FCR_TRG_LEV2)
 */
STATIC INLINE void Chip_UART_SetupFIFOS(LPC_USART_T *pUART, uint32_t fcr)
{
	pUART->FCR = fcr;
1a000ac6:	2307      	movs	r3, #7
1a000ac8:	60a3      	str	r3, [r4, #8]
 * @param	pUART	: Pointer to selected pUART peripheral
 * @return Nothing
 */
STATIC INLINE void Chip_UART_TXDisable(LPC_USART_T *pUART)
{
    pUART->TER2 = 0;
1a000aca:	2300      	movs	r3, #0
1a000acc:	65e3      	str	r3, [r4, #92]	; 0x5c

    /* Disable Tx */
    Chip_UART_TXDisable(pUART);

    /* Disable interrupts */
	pUART->IER = 0;
1a000ace:	6063      	str	r3, [r4, #4]
	/* Set LCR to default state */
	pUART->LCR = 0;
1a000ad0:	60e3      	str	r3, [r4, #12]
	/* Set ACR to default state */
	pUART->ACR = 0;
1a000ad2:	6223      	str	r3, [r4, #32]
    /* Set RS485 control to default state */
	pUART->RS485CTRL = 0;
1a000ad4:	64e3      	str	r3, [r4, #76]	; 0x4c
	/* Set RS485 delay timer to default state */
	pUART->RS485DLY = 0;
1a000ad6:	6563      	str	r3, [r4, #84]	; 0x54
	/* Set RS485 addr match to default state */
	pUART->RS485ADRMATCH = 0;
1a000ad8:	6523      	str	r3, [r4, #80]	; 0x50

    /* Clear MCR */
    if (pUART == LPC_UART1) {
1a000ada:	4b08      	ldr	r3, [pc, #32]	; (1a000afc <Chip_UART_Init+0x50>)
1a000adc:	429c      	cmp	r4, r3
1a000ade:	d103      	bne.n	1a000ae8 <Chip_UART_Init+0x3c>
		/* Set Modem Control to default state */
		pUART->MCR = 0;
1a000ae0:	2300      	movs	r3, #0
1a000ae2:	6123      	str	r3, [r4, #16]
		/*Dummy Reading to Clear Status */
		tmp = pUART->MSR;
1a000ae4:	69a3      	ldr	r3, [r4, #24]
1a000ae6:	9301      	str	r3, [sp, #4]
 *			stop bit, and even (enabled) parity would be
 *			(UART_LCR_WLEN8 | UART_LCR_SBS_1BIT | UART_LCR_PARITY_EN | UART_LCR_PARITY_EVEN)
 */
STATIC INLINE void Chip_UART_ConfigData(LPC_USART_T *pUART, uint32_t config)
{
	pUART->LCR = config;
1a000ae8:	2303      	movs	r3, #3
1a000aea:	60e3      	str	r3, [r4, #12]

	/* Default 8N1, with DLAB disabled */
	Chip_UART_ConfigData(pUART, (UART_LCR_WLEN8 | UART_LCR_SBS_1BIT | UART_LCR_PARITY_DIS));

	/* Disable fractional divider */
	pUART->FDR = 0x10;
1a000aec:	2310      	movs	r3, #16
1a000aee:	62a3      	str	r3, [r4, #40]	; 0x28

    (void) tmp;
1a000af0:	9b01      	ldr	r3, [sp, #4]
}
1a000af2:	b002      	add	sp, #8
1a000af4:	bd10      	pop	{r4, pc}
1a000af6:	bf00      	nop
1a000af8:	1a001d4c 	.word	0x1a001d4c
1a000afc:	40082000 	.word	0x40082000

1a000b00 <Chip_UART_SetBaudFDR>:
    Chip_UART_ABIntHandler(pUART);
}

/* Determines and sets best dividers to get a target baud rate */
uint32_t Chip_UART_SetBaudFDR(LPC_USART_T *pUART, uint32_t baud)
{
1a000b00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1a000b04:	b083      	sub	sp, #12
1a000b06:	4683      	mov	fp, r0
1a000b08:	4688      	mov	r8, r1
	uint32_t sdiv = 0, sm = 1, sd = 0;
	uint32_t pclk, m, d;
	uint32_t odiff = -1UL; /* old best diff */

	/* Get base clock for the corresponding UART */
	pclk = Chip_Clock_GetRate(UART_BClock[Chip_UART_GetIndex(pUART)]);
1a000b0a:	f7ff ffb9 	bl	1a000a80 <Chip_UART_GetIndex>
1a000b0e:	4b34      	ldr	r3, [pc, #208]	; (1a000be0 <Chip_UART_SetBaudFDR+0xe0>)
1a000b10:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
1a000b14:	f000 fb64 	bl	1a0011e0 <Chip_Clock_GetRate>
1a000b18:	4606      	mov	r6, r0
/* Determines and sets best dividers to get a target baud rate */
uint32_t Chip_UART_SetBaudFDR(LPC_USART_T *pUART, uint32_t baud)
{
	uint32_t sdiv = 0, sm = 1, sd = 0;
	uint32_t pclk, m, d;
	uint32_t odiff = -1UL; /* old best diff */
1a000b1a:	f04f 37ff 	mov.w	r7, #4294967295

	/* Get base clock for the corresponding UART */
	pclk = Chip_Clock_GetRate(UART_BClock[Chip_UART_GetIndex(pUART)]);

	/* Loop through all possible fractional divider values */
	for (m = 1; odiff && m < 16; m++) {
1a000b1e:	2401      	movs	r4, #1
}

/* Determines and sets best dividers to get a target baud rate */
uint32_t Chip_UART_SetBaudFDR(LPC_USART_T *pUART, uint32_t baud)
{
	uint32_t sdiv = 0, sm = 1, sd = 0;
1a000b20:	2300      	movs	r3, #0
1a000b22:	9301      	str	r3, [sp, #4]
1a000b24:	46a2      	mov	sl, r4
1a000b26:	4699      	mov	r9, r3

	/* Get base clock for the corresponding UART */
	pclk = Chip_Clock_GetRate(UART_BClock[Chip_UART_GetIndex(pUART)]);

	/* Loop through all possible fractional divider values */
	for (m = 1; odiff && m < 16; m++) {
1a000b28:	e029      	b.n	1a000b7e <Chip_UART_SetBaudFDR+0x7e>
		for (d = 0; d < m; d++) {
			uint32_t diff, div;
			uint64_t dval = (((uint64_t) pclk << 28) * m) / (baud * (m + d));
1a000b2a:	2300      	movs	r3, #0
1a000b2c:	0932      	lsrs	r2, r6, #4
1a000b2e:	0730      	lsls	r0, r6, #28
1a000b30:	fba0 0104 	umull	r0, r1, r0, r4
1a000b34:	fb04 1102 	mla	r1, r4, r2, r1
1a000b38:	1962      	adds	r2, r4, r5
1a000b3a:	fb08 f202 	mul.w	r2, r8, r2
1a000b3e:	f000 fd43 	bl	1a0015c8 <__aeabi_uldivmod>

			/* Lower 32-bit of dval has diff */
			diff = (uint32_t) dval;
1a000b42:	4603      	mov	r3, r0
			/* Upper 32-bit of dval has div */
			div = (uint32_t) (dval >> 32);
1a000b44:	460a      	mov	r2, r1

			/* Closer to next div */
			if ((int)diff < 0) {
1a000b46:	2800      	cmp	r0, #0
1a000b48:	da01      	bge.n	1a000b4e <Chip_UART_SetBaudFDR+0x4e>
				diff = -diff;
1a000b4a:	4243      	negs	r3, r0
				div ++;
1a000b4c:	1c4a      	adds	r2, r1, #1
			}

			/* Check if new value is worse than old or out of range */
			if (odiff < diff || !div || (div >> 16) || (div < 3 && d)) {
1a000b4e:	429f      	cmp	r7, r3
1a000b50:	d30a      	bcc.n	1a000b68 <Chip_UART_SetBaudFDR+0x68>
1a000b52:	b14a      	cbz	r2, 1a000b68 <Chip_UART_SetBaudFDR+0x68>
1a000b54:	0c11      	lsrs	r1, r2, #16
1a000b56:	d107      	bne.n	1a000b68 <Chip_UART_SetBaudFDR+0x68>
1a000b58:	2a02      	cmp	r2, #2
1a000b5a:	d800      	bhi.n	1a000b5e <Chip_UART_SetBaudFDR+0x5e>
1a000b5c:	b925      	cbnz	r5, 1a000b68 <Chip_UART_SetBaudFDR+0x68>
			sd = d;
			sm = m;
			odiff = diff;

			/* On perfect match, break loop */
			if(!diff) {
1a000b5e:	b14b      	cbz	r3, 1a000b74 <Chip_UART_SetBaudFDR+0x74>

			/* Store the new better values */
			sdiv = div;
			sd = d;
			sm = m;
			odiff = diff;
1a000b60:	461f      	mov	r7, r3
				continue;
			}

			/* Store the new better values */
			sdiv = div;
			sd = d;
1a000b62:	9501      	str	r5, [sp, #4]
			sm = m;
1a000b64:	46a2      	mov	sl, r4
			if (odiff < diff || !div || (div >> 16) || (div < 3 && d)) {
				continue;
			}

			/* Store the new better values */
			sdiv = div;
1a000b66:	4691      	mov	r9, r2
	/* Get base clock for the corresponding UART */
	pclk = Chip_Clock_GetRate(UART_BClock[Chip_UART_GetIndex(pUART)]);

	/* Loop through all possible fractional divider values */
	for (m = 1; odiff && m < 16; m++) {
		for (d = 0; d < m; d++) {
1a000b68:	3501      	adds	r5, #1
1a000b6a:	e000      	b.n	1a000b6e <Chip_UART_SetBaudFDR+0x6e>
1a000b6c:	2500      	movs	r5, #0
1a000b6e:	42a5      	cmp	r5, r4
1a000b70:	d3db      	bcc.n	1a000b2a <Chip_UART_SetBaudFDR+0x2a>
1a000b72:	e003      	b.n	1a000b7c <Chip_UART_SetBaudFDR+0x7c>

			/* Store the new better values */
			sdiv = div;
			sd = d;
			sm = m;
			odiff = diff;
1a000b74:	461f      	mov	r7, r3
				continue;
			}

			/* Store the new better values */
			sdiv = div;
			sd = d;
1a000b76:	9501      	str	r5, [sp, #4]
			sm = m;
1a000b78:	46a2      	mov	sl, r4
			if (odiff < diff || !div || (div >> 16) || (div < 3 && d)) {
				continue;
			}

			/* Store the new better values */
			sdiv = div;
1a000b7a:	4691      	mov	r9, r2

	/* Get base clock for the corresponding UART */
	pclk = Chip_Clock_GetRate(UART_BClock[Chip_UART_GetIndex(pUART)]);

	/* Loop through all possible fractional divider values */
	for (m = 1; odiff && m < 16; m++) {
1a000b7c:	3401      	adds	r4, #1
1a000b7e:	b10f      	cbz	r7, 1a000b84 <Chip_UART_SetBaudFDR+0x84>
1a000b80:	2c0f      	cmp	r4, #15
1a000b82:	d9f3      	bls.n	1a000b6c <Chip_UART_SetBaudFDR+0x6c>
			}
		}
	}

	/* Return 0 if a vaild divisor is not possible */
	if (!sdiv) {
1a000b84:	f1b9 0f00 	cmp.w	r9, #0
1a000b88:	d026      	beq.n	1a000bd8 <Chip_UART_SetBaudFDR+0xd8>
 * @param	pUART	: Pointer to selected UART peripheral
 * @return	Nothing
 */
STATIC INLINE void Chip_UART_EnableDivisorAccess(LPC_USART_T *pUART)
{
	pUART->LCR |= UART_LCR_DLAB_EN;
1a000b8a:	f8db 300c 	ldr.w	r3, [fp, #12]
1a000b8e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
1a000b92:	f8cb 300c 	str.w	r3, [fp, #12]
 *			order to access the USART Divisor Latches. This function
 *			doesn't alter the DLAB state.
 */
STATIC INLINE void Chip_UART_SetDivisorLatches(LPC_USART_T *pUART, uint8_t dll, uint8_t dlm)
{
	pUART->DLL = (uint32_t) dll;
1a000b96:	fa5f f389 	uxtb.w	r3, r9
1a000b9a:	f8cb 3000 	str.w	r3, [fp]
	pUART->DLM = (uint32_t) dlm;
1a000b9e:	f3c9 2307 	ubfx	r3, r9, #8, #8
1a000ba2:	f8cb 3004 	str.w	r3, [fp, #4]
 * @param	pUART	: Pointer to selected UART peripheral
 * @return	Nothing
 */
STATIC INLINE void Chip_UART_DisableDivisorAccess(LPC_USART_T *pUART)
{
	pUART->LCR &= ~UART_LCR_DLAB_EN;
1a000ba6:	f8db 300c 	ldr.w	r3, [fp, #12]
1a000baa:	f023 0380 	bic.w	r3, r3, #128	; 0x80
1a000bae:	f8cb 300c 	str.w	r3, [fp, #12]
	Chip_UART_EnableDivisorAccess(pUART);
	Chip_UART_SetDivisorLatches(pUART, UART_LOAD_DLL(sdiv), UART_LOAD_DLM(sdiv));
	Chip_UART_DisableDivisorAccess(pUART);

	/* Set best fractional divider */
	pUART->FDR = (UART_FDR_MULVAL(sm) | UART_FDR_DIVADDVAL(sd));
1a000bb2:	ea4f 130a 	mov.w	r3, sl, lsl #4
1a000bb6:	b2da      	uxtb	r2, r3
1a000bb8:	9901      	ldr	r1, [sp, #4]
1a000bba:	f001 030f 	and.w	r3, r1, #15
1a000bbe:	4313      	orrs	r3, r2
1a000bc0:	f8cb 3028 	str.w	r3, [fp, #40]	; 0x28

	/* Return actual baud rate */
	return (pclk >> 4) * sm / (sdiv * (sm + sd));
1a000bc4:	0933      	lsrs	r3, r6, #4
1a000bc6:	fb0a f303 	mul.w	r3, sl, r3
1a000bca:	eb0a 0001 	add.w	r0, sl, r1
1a000bce:	fb09 f000 	mul.w	r0, r9, r0
1a000bd2:	fbb3 f0f0 	udiv	r0, r3, r0
1a000bd6:	e000      	b.n	1a000bda <Chip_UART_SetBaudFDR+0xda>
		}
	}

	/* Return 0 if a vaild divisor is not possible */
	if (!sdiv) {
		return 0;
1a000bd8:	2000      	movs	r0, #0
	/* Set best fractional divider */
	pUART->FDR = (UART_FDR_MULVAL(sm) | UART_FDR_DIVADDVAL(sd));

	/* Return actual baud rate */
	return (pclk >> 4) * sm / (sdiv * (sm + sd));
}
1a000bda:	b003      	add	sp, #12
1a000bdc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
1a000be0:	1a001d44 	.word	0x1a001d44

1a000be4 <Chip_ADC_GetClockIndex>:
/* Returns clock index for the peripheral block */
STATIC CHIP_CCU_CLK_T Chip_ADC_GetClockIndex(LPC_ADC_T *pADC)
{
	CHIP_CCU_CLK_T clkADC;

	if (pADC == LPC_ADC1) {
1a000be4:	4b03      	ldr	r3, [pc, #12]	; (1a000bf4 <Chip_ADC_GetClockIndex+0x10>)
1a000be6:	4298      	cmp	r0, r3
1a000be8:	d101      	bne.n	1a000bee <Chip_ADC_GetClockIndex+0xa>
		clkADC = CLK_APB3_ADC1;
1a000bea:	2004      	movs	r0, #4
1a000bec:	4770      	bx	lr
	}
	else {
		clkADC = CLK_APB3_ADC0;
1a000bee:	2003      	movs	r0, #3
	}

	return clkADC;
}
1a000bf0:	4770      	bx	lr
1a000bf2:	bf00      	nop
1a000bf4:	400e4000 	.word	0x400e4000

1a000bf8 <getClkDiv>:

/* Get divider value */
STATIC uint8_t getClkDiv(LPC_ADC_T *pADC, bool burstMode, uint32_t adcRate, uint8_t clks)
{
1a000bf8:	b570      	push	{r4, r5, r6, lr}
1a000bfa:	460d      	mov	r5, r1
1a000bfc:	4614      	mov	r4, r2
1a000bfe:	461e      	mov	r6, r3
	   A/D converter, which should be less than or equal to 4.5MHz.
	   A fully conversion requires (bits_accuracy+1) of these clocks.
	   ADC Clock = PCLK_ADC0 / (CLKDIV + 1);
	   ADC rate = ADC clock / (the number of clocks required for each conversion);
	 */
	adcBlockFreq = Chip_Clock_GetRate(Chip_ADC_GetClockIndex(pADC));
1a000c00:	f7ff fff0 	bl	1a000be4 <Chip_ADC_GetClockIndex>
1a000c04:	f000 faec 	bl	1a0011e0 <Chip_Clock_GetRate>
	if (burstMode) {
1a000c08:	b115      	cbz	r5, 1a000c10 <getClkDiv+0x18>
		fullAdcRate = adcRate * clks;
1a000c0a:	fb04 f406 	mul.w	r4, r4, r6
1a000c0e:	e003      	b.n	1a000c18 <getClkDiv+0x20>
	}
	else {
		fullAdcRate = adcRate * getFullConvClk();
1a000c10:	eb04 0384 	add.w	r3, r4, r4, lsl #2
1a000c14:	eb04 0443 	add.w	r4, r4, r3, lsl #1
	}

	/* Get the round value by fomular: (2*A + B)/(2*B) */
	div = ((adcBlockFreq * 2 + fullAdcRate) / (fullAdcRate * 2)) - 1;
1a000c18:	eb04 0040 	add.w	r0, r4, r0, lsl #1
1a000c1c:	0064      	lsls	r4, r4, #1
1a000c1e:	fbb0 f4f4 	udiv	r4, r0, r4
1a000c22:	1e60      	subs	r0, r4, #1
	return div;
}
1a000c24:	b2c0      	uxtb	r0, r0
1a000c26:	bd70      	pop	{r4, r5, r6, pc}

1a000c28 <Chip_ADC_Init>:
 * Public functions
 ****************************************************************************/

/* Initialize the ADC peripheral and the ADC setup structure to default value */
void Chip_ADC_Init(LPC_ADC_T *pADC, ADC_CLOCK_SETUP_T *ADCSetup)
{
1a000c28:	b538      	push	{r3, r4, r5, lr}
1a000c2a:	4605      	mov	r5, r0
1a000c2c:	460c      	mov	r4, r1
	uint8_t div;
	uint32_t cr = 0;
	uint32_t clk;

	Chip_Clock_EnableOpts(Chip_ADC_GetClockIndex(pADC), true, true, 1);
1a000c2e:	f7ff ffd9 	bl	1a000be4 <Chip_ADC_GetClockIndex>
1a000c32:	2101      	movs	r1, #1
1a000c34:	460a      	mov	r2, r1
1a000c36:	460b      	mov	r3, r1
1a000c38:	f000 fa9a 	bl	1a001170 <Chip_Clock_EnableOpts>

	pADC->INTEN = 0;		/* Disable all interrupts */
1a000c3c:	2100      	movs	r1, #0
1a000c3e:	60e9      	str	r1, [r5, #12]

	cr |= ADC_CR_PDN;
	ADCSetup->adcRate = ADC_MAX_SAMPLE_RATE;
1a000c40:	4a08      	ldr	r2, [pc, #32]	; (1a000c64 <Chip_ADC_Init+0x3c>)
1a000c42:	6022      	str	r2, [r4, #0]
	ADCSetup->bitsAccuracy = ADC_10BITS;
1a000c44:	7121      	strb	r1, [r4, #4]
	clk = 11;
	ADCSetup->burstMode = false;
1a000c46:	7161      	strb	r1, [r4, #5]
	div = getClkDiv(pADC, false, ADCSetup->adcRate, clk);
1a000c48:	4628      	mov	r0, r5
1a000c4a:	230b      	movs	r3, #11
1a000c4c:	f7ff ffd4 	bl	1a000bf8 <getClkDiv>
	cr |= ADC_CR_CLKDIV(div);
1a000c50:	0200      	lsls	r0, r0, #8
1a000c52:	f440 1300 	orr.w	r3, r0, #2097152	; 0x200000
	cr |= ADC_CR_BITACC(ADCSetup->bitsAccuracy);
1a000c56:	7920      	ldrb	r0, [r4, #4]
1a000c58:	f000 0007 	and.w	r0, r0, #7
1a000c5c:	ea43 4040 	orr.w	r0, r3, r0, lsl #17
	pADC->CR = cr;
1a000c60:	6028      	str	r0, [r5, #0]
1a000c62:	bd38      	pop	{r3, r4, r5, pc}
1a000c64:	00061a80 	.word	0x00061a80

1a000c68 <Chip_ADC_SetSampleRate>:
	setStartMode(pADC, (uint8_t) mode);
}

/* Set the ADC Sample rate */
void Chip_ADC_SetSampleRate(LPC_ADC_T *pADC, ADC_CLOCK_SETUP_T *ADCSetup, uint32_t rate)
{
1a000c68:	b570      	push	{r4, r5, r6, lr}
1a000c6a:	4606      	mov	r6, r0
1a000c6c:	460d      	mov	r5, r1
	uint8_t div;
	uint32_t cr;

	cr = pADC->CR & (~ADC_SAMPLE_RATE_CONFIG_MASK);
1a000c6e:	6804      	ldr	r4, [r0, #0]
1a000c70:	f424 246f 	bic.w	r4, r4, #978944	; 0xef000
1a000c74:	f424 6470 	bic.w	r4, r4, #3840	; 0xf00
	ADCSetup->adcRate = rate;
1a000c78:	600a      	str	r2, [r1, #0]
	div = getClkDiv(pADC, ADCSetup->burstMode, rate, (11 - ADCSetup->bitsAccuracy));
1a000c7a:	790b      	ldrb	r3, [r1, #4]
1a000c7c:	f1c3 030b 	rsb	r3, r3, #11
1a000c80:	7949      	ldrb	r1, [r1, #5]
1a000c82:	b2db      	uxtb	r3, r3
1a000c84:	f7ff ffb8 	bl	1a000bf8 <getClkDiv>
	cr |= ADC_CR_CLKDIV(div);
1a000c88:	ea44 2000 	orr.w	r0, r4, r0, lsl #8
	cr |= ADC_CR_BITACC(ADCSetup->bitsAccuracy);
1a000c8c:	792c      	ldrb	r4, [r5, #4]
1a000c8e:	f004 0407 	and.w	r4, r4, #7
1a000c92:	ea40 4044 	orr.w	r0, r0, r4, lsl #17
	pADC->CR = cr;
1a000c96:	6030      	str	r0, [r6, #0]
1a000c98:	bd70      	pop	{r4, r5, r6, pc}
1a000c9a:	bf00      	nop

1a000c9c <Chip_ADC_SetResolution>:
}

/* Set the ADC accuracy bits */
void Chip_ADC_SetResolution(LPC_ADC_T *pADC, ADC_CLOCK_SETUP_T *ADCSetup, ADC_RESOLUTION_T resolution)
{
1a000c9c:	b508      	push	{r3, lr}
	ADCSetup->bitsAccuracy = resolution;
1a000c9e:	710a      	strb	r2, [r1, #4]
	Chip_ADC_SetSampleRate(pADC, ADCSetup, ADCSetup->adcRate);
1a000ca0:	680a      	ldr	r2, [r1, #0]
1a000ca2:	f7ff ffe1 	bl	1a000c68 <Chip_ADC_SetSampleRate>
1a000ca6:	bd08      	pop	{r3, pc}

1a000ca8 <pll_calc_divs>:
		return -val;
	return val;
}

static void pll_calc_divs(uint32_t freq, PLL_PARAM_T *ppll)
{
1a000ca8:	b5f0      	push	{r4, r5, r6, r7, lr}

	uint32_t prev = freq;
	int n, m, p;

	/* When direct mode is set FBSEL should be a don't care */
	if (ppll->ctrl & (1 << 7)) {
1a000caa:	680b      	ldr	r3, [r1, #0]
1a000cac:	f013 0f80 	tst.w	r3, #128	; 0x80
1a000cb0:	d002      	beq.n	1a000cb8 <pll_calc_divs+0x10>
		ppll->ctrl &= ~(1 << 6);
1a000cb2:	f023 0340 	bic.w	r3, r3, #64	; 0x40
1a000cb6:	600b      	str	r3, [r1, #0]
1a000cb8:	4686      	mov	lr, r0
1a000cba:	2601      	movs	r6, #1
1a000cbc:	e041      	b.n	1a000d42 <pll_calc_divs+0x9a>
	}
	for (n = 1; n <= 4; n++) {
		for (p = 0; p < 4; p ++) {
			for (m = 1; m <= 256; m++) {
				uint32_t fcco, fout;
				if (ppll->ctrl & (1 << 6)) {
1a000cbe:	680d      	ldr	r5, [r1, #0]
1a000cc0:	f015 0f40 	tst.w	r5, #64	; 0x40
1a000cc4:	d008      	beq.n	1a000cd8 <pll_calc_divs+0x30>
					fcco = ((m << (p + 1)) * ppll->fin) / n;
1a000cc6:	1c7b      	adds	r3, r7, #1
1a000cc8:	fa04 f203 	lsl.w	r2, r4, r3
1a000ccc:	694b      	ldr	r3, [r1, #20]
1a000cce:	fb03 f302 	mul.w	r3, r3, r2
1a000cd2:	fbb3 f3f6 	udiv	r3, r3, r6
1a000cd6:	e004      	b.n	1a000ce2 <pll_calc_divs+0x3a>
				} else {
					fcco = (m * ppll->fin) / n;
1a000cd8:	694b      	ldr	r3, [r1, #20]
1a000cda:	fb04 f303 	mul.w	r3, r4, r3
1a000cde:	fbb3 f3f6 	udiv	r3, r3, r6
				}
				if (fcco < PLL_MIN_CCO_FREQ) continue;
1a000ce2:	4a19      	ldr	r2, [pc, #100]	; (1a000d48 <pll_calc_divs+0xa0>)
1a000ce4:	4293      	cmp	r3, r2
1a000ce6:	d920      	bls.n	1a000d2a <pll_calc_divs+0x82>
				if (fcco > PLL_MAX_CCO_FREQ) break;
1a000ce8:	4a18      	ldr	r2, [pc, #96]	; (1a000d4c <pll_calc_divs+0xa4>)
1a000cea:	4293      	cmp	r3, r2
1a000cec:	d823      	bhi.n	1a000d36 <pll_calc_divs+0x8e>
				if (ppll->ctrl & (1 << 7)) {
1a000cee:	f015 0f80 	tst.w	r5, #128	; 0x80
1a000cf2:	d103      	bne.n	1a000cfc <pll_calc_divs+0x54>
					fout = fcco;
				} else {
					fout = fcco >> (p + 1);
1a000cf4:	1c7a      	adds	r2, r7, #1
1a000cf6:	fa23 f202 	lsr.w	r2, r3, r2
1a000cfa:	e000      	b.n	1a000cfe <pll_calc_divs+0x56>
					fcco = (m * ppll->fin) / n;
				}
				if (fcco < PLL_MIN_CCO_FREQ) continue;
				if (fcco > PLL_MAX_CCO_FREQ) break;
				if (ppll->ctrl & (1 << 7)) {
					fout = fcco;
1a000cfc:	461a      	mov	r2, r3
/*****************************************************************************
 * Private functions
 ****************************************************************************/
__STATIC_INLINE uint32_t ABS(int val)
{
	if (val < 0)
1a000cfe:	1a85      	subs	r5, r0, r2
1a000d00:	d502      	bpl.n	1a000d08 <pll_calc_divs+0x60>
		return -val;
1a000d02:	f1c5 0c00 	rsb	ip, r5, #0
1a000d06:	e000      	b.n	1a000d0a <pll_calc_divs+0x62>
	return val;
1a000d08:	46ac      	mov	ip, r5
					fout = fcco;
				} else {
					fout = fcco >> (p + 1);
				}

				if (ABS(freq - fout) < prev) {
1a000d0a:	45e6      	cmp	lr, ip
1a000d0c:	d90d      	bls.n	1a000d2a <pll_calc_divs+0x82>
					ppll->nsel = n;
1a000d0e:	608e      	str	r6, [r1, #8]
					ppll->psel = p + 1;
1a000d10:	f107 0e01 	add.w	lr, r7, #1
1a000d14:	f8c1 e00c 	str.w	lr, [r1, #12]
					ppll->msel = m;
1a000d18:	610c      	str	r4, [r1, #16]
					ppll->fout = fout;
1a000d1a:	618a      	str	r2, [r1, #24]
					ppll->fcco = fcco;
1a000d1c:	61cb      	str	r3, [r1, #28]
/*****************************************************************************
 * Private functions
 ****************************************************************************/
__STATIC_INLINE uint32_t ABS(int val)
{
	if (val < 0)
1a000d1e:	2d00      	cmp	r5, #0
1a000d20:	da02      	bge.n	1a000d28 <pll_calc_divs+0x80>
		return -val;
1a000d22:	f1c5 0e00 	rsb	lr, r5, #0
1a000d26:	e000      	b.n	1a000d2a <pll_calc_divs+0x82>
	return val;
1a000d28:	46ae      	mov	lr, r5
	if (ppll->ctrl & (1 << 7)) {
		ppll->ctrl &= ~(1 << 6);
	}
	for (n = 1; n <= 4; n++) {
		for (p = 0; p < 4; p ++) {
			for (m = 1; m <= 256; m++) {
1a000d2a:	3401      	adds	r4, #1
1a000d2c:	e000      	b.n	1a000d30 <pll_calc_divs+0x88>
1a000d2e:	2401      	movs	r4, #1
1a000d30:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
1a000d34:	ddc3      	ble.n	1a000cbe <pll_calc_divs+0x16>
	/* When direct mode is set FBSEL should be a don't care */
	if (ppll->ctrl & (1 << 7)) {
		ppll->ctrl &= ~(1 << 6);
	}
	for (n = 1; n <= 4; n++) {
		for (p = 0; p < 4; p ++) {
1a000d36:	3701      	adds	r7, #1
1a000d38:	e000      	b.n	1a000d3c <pll_calc_divs+0x94>
1a000d3a:	2700      	movs	r7, #0
1a000d3c:	2f03      	cmp	r7, #3
1a000d3e:	ddf6      	ble.n	1a000d2e <pll_calc_divs+0x86>

	/* When direct mode is set FBSEL should be a don't care */
	if (ppll->ctrl & (1 << 7)) {
		ppll->ctrl &= ~(1 << 6);
	}
	for (n = 1; n <= 4; n++) {
1a000d40:	3601      	adds	r6, #1
1a000d42:	2e04      	cmp	r6, #4
1a000d44:	ddf9      	ble.n	1a000d3a <pll_calc_divs+0x92>
					prev = ABS(freq - fout);
				}
			}
		}
	}
}
1a000d46:	bdf0      	pop	{r4, r5, r6, r7, pc}
1a000d48:	094c5eff 	.word	0x094c5eff
1a000d4c:	1312d000 	.word	0x1312d000

1a000d50 <pll_get_frac>:

static void pll_get_frac(uint32_t freq, PLL_PARAM_T *ppll)
{
1a000d50:	b5f0      	push	{r4, r5, r6, r7, lr}
1a000d52:	b099      	sub	sp, #100	; 0x64
1a000d54:	4605      	mov	r5, r0
1a000d56:	460c      	mov	r4, r1
	int diff[3];
	PLL_PARAM_T pll[3] = {{0},{0},{0}};
1a000d58:	4668      	mov	r0, sp
1a000d5a:	2100      	movs	r1, #0
1a000d5c:	2260      	movs	r2, #96	; 0x60
1a000d5e:	f000 ff27 	bl	1a001bb0 <memset>

	/* Try direct mode */
	pll[0].ctrl |= (1 << 7);
1a000d62:	2380      	movs	r3, #128	; 0x80
1a000d64:	9300      	str	r3, [sp, #0]
	pll[0].fin = ppll->fin;
1a000d66:	6963      	ldr	r3, [r4, #20]
1a000d68:	9305      	str	r3, [sp, #20]
	pll[0].srcin = ppll->srcin;
1a000d6a:	7923      	ldrb	r3, [r4, #4]
1a000d6c:	f88d 3004 	strb.w	r3, [sp, #4]
	pll_calc_divs(freq, &pll[0]);
1a000d70:	4628      	mov	r0, r5
1a000d72:	4669      	mov	r1, sp
1a000d74:	f7ff ff98 	bl	1a000ca8 <pll_calc_divs>
	if (pll[0].fout == freq) {
1a000d78:	9b06      	ldr	r3, [sp, #24]
1a000d7a:	42ab      	cmp	r3, r5
1a000d7c:	d107      	bne.n	1a000d8e <pll_get_frac+0x3e>
		*ppll = pll[0];
1a000d7e:	466d      	mov	r5, sp
1a000d80:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a000d82:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a000d84:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a000d88:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
		return ;
1a000d8c:	e05e      	b.n	1a000e4c <pll_get_frac+0xfc>
/*****************************************************************************
 * Private functions
 ****************************************************************************/
__STATIC_INLINE uint32_t ABS(int val)
{
	if (val < 0)
1a000d8e:	1aeb      	subs	r3, r5, r3
1a000d90:	d500      	bpl.n	1a000d94 <pll_get_frac+0x44>
		return -val;
1a000d92:	425b      	negs	r3, r3
	pll_calc_divs(freq, &pll[0]);
	if (pll[0].fout == freq) {
		*ppll = pll[0];
		return ;
	}
	diff[0] = ABS(freq - pll[0].fout);
1a000d94:	461e      	mov	r6, r3

	/* Try non-Integer mode */
	pll[2].ctrl &= ~(1 << 6);			// need to set FBSEL to 0
1a000d96:	9b10      	ldr	r3, [sp, #64]	; 0x40
1a000d98:	f023 0340 	bic.w	r3, r3, #64	; 0x40
1a000d9c:	9310      	str	r3, [sp, #64]	; 0x40
	pll[2].fin = ppll->fin;
1a000d9e:	6963      	ldr	r3, [r4, #20]
1a000da0:	9315      	str	r3, [sp, #84]	; 0x54
	pll[2].srcin = ppll->srcin;
1a000da2:	7923      	ldrb	r3, [r4, #4]
1a000da4:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
	pll_calc_divs(freq, &pll[2]);
1a000da8:	4628      	mov	r0, r5
1a000daa:	a910      	add	r1, sp, #64	; 0x40
1a000dac:	f7ff ff7c 	bl	1a000ca8 <pll_calc_divs>
	if (pll[2].fout == freq) {
1a000db0:	9b16      	ldr	r3, [sp, #88]	; 0x58
1a000db2:	42ab      	cmp	r3, r5
1a000db4:	d107      	bne.n	1a000dc6 <pll_get_frac+0x76>
		*ppll = pll[2];
1a000db6:	ad10      	add	r5, sp, #64	; 0x40
1a000db8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a000dba:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a000dbc:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a000dc0:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
		return ;
1a000dc4:	e042      	b.n	1a000e4c <pll_get_frac+0xfc>
/*****************************************************************************
 * Private functions
 ****************************************************************************/
__STATIC_INLINE uint32_t ABS(int val)
{
	if (val < 0)
1a000dc6:	1aeb      	subs	r3, r5, r3
1a000dc8:	d500      	bpl.n	1a000dcc <pll_get_frac+0x7c>
		return -val;
1a000dca:	425b      	negs	r3, r3
	pll_calc_divs(freq, &pll[2]);
	if (pll[2].fout == freq) {
		*ppll = pll[2];
		return ;
	}
	diff[2] = ABS(freq - pll[2].fout);
1a000dcc:	461f      	mov	r7, r3
	
	if (freq <= 110000000) {
1a000dce:	4b20      	ldr	r3, [pc, #128]	; (1a000e50 <pll_get_frac+0x100>)
1a000dd0:	429d      	cmp	r5, r3
1a000dd2:	d812      	bhi.n	1a000dfa <pll_get_frac+0xaa>
		/* Try integer mode */
		pll[1].ctrl = (1 << 6);
1a000dd4:	2340      	movs	r3, #64	; 0x40
1a000dd6:	9308      	str	r3, [sp, #32]
		pll[1].fin = ppll->fin;
1a000dd8:	6963      	ldr	r3, [r4, #20]
1a000dda:	930d      	str	r3, [sp, #52]	; 0x34
		pll_calc_divs(freq, &pll[1]);
1a000ddc:	4628      	mov	r0, r5
1a000dde:	a908      	add	r1, sp, #32
1a000de0:	f7ff ff62 	bl	1a000ca8 <pll_calc_divs>
		if (pll[1].fout == freq) {
1a000de4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
1a000de6:	42ab      	cmp	r3, r5
1a000de8:	d107      	bne.n	1a000dfa <pll_get_frac+0xaa>
			*ppll = pll[1];
1a000dea:	ad08      	add	r5, sp, #32
1a000dec:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a000dee:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a000df0:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a000df4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
			return ;
1a000df8:	e028      	b.n	1a000e4c <pll_get_frac+0xfc>
		}
	}
	diff[1] = ABS(freq - pll[1].fout);
1a000dfa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
/*****************************************************************************
 * Private functions
 ****************************************************************************/
__STATIC_INLINE uint32_t ABS(int val)
{
	if (val < 0)
1a000dfc:	1aed      	subs	r5, r5, r3
1a000dfe:	d500      	bpl.n	1a000e02 <pll_get_frac+0xb2>
		return -val;
1a000e00:	426d      	negs	r5, r5
		}
	}
	diff[1] = ABS(freq - pll[1].fout);

	/* Find the min of 3 and return */
	if (diff[0] <= diff[1]) {
1a000e02:	42ae      	cmp	r6, r5
1a000e04:	dc11      	bgt.n	1a000e2a <pll_get_frac+0xda>
		if (diff[0] <= diff[2]) {
1a000e06:	42be      	cmp	r6, r7
1a000e08:	dc07      	bgt.n	1a000e1a <pll_get_frac+0xca>
			*ppll = pll[0];
1a000e0a:	466d      	mov	r5, sp
1a000e0c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a000e0e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a000e10:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a000e14:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
1a000e18:	e018      	b.n	1a000e4c <pll_get_frac+0xfc>
		} else {
			*ppll = pll[2];
1a000e1a:	ad10      	add	r5, sp, #64	; 0x40
1a000e1c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a000e1e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a000e20:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a000e24:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
1a000e28:	e010      	b.n	1a000e4c <pll_get_frac+0xfc>
		}
	} else {
		if (diff[1] <= diff[2]) {
1a000e2a:	42af      	cmp	r7, r5
1a000e2c:	db07      	blt.n	1a000e3e <pll_get_frac+0xee>
			*ppll = pll[1];
1a000e2e:	ad08      	add	r5, sp, #32
1a000e30:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a000e32:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a000e34:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a000e38:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
1a000e3c:	e006      	b.n	1a000e4c <pll_get_frac+0xfc>
		} else {
			*ppll = pll[2];
1a000e3e:	ad10      	add	r5, sp, #64	; 0x40
1a000e40:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1a000e42:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1a000e44:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1a000e48:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
		}
	}
}
1a000e4c:	b019      	add	sp, #100	; 0x64
1a000e4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
1a000e50:	068e7780 	.word	0x068e7780

1a000e54 <Chip_Clock_FindBaseClock>:
	return Chip_Clock_GetClockInputHz(input) / (div + 1);
}

/* Finds the base clock for the peripheral clock */
static CHIP_CGU_BASE_CLK_T Chip_Clock_FindBaseClock(CHIP_CCU_CLK_T clk)
{
1a000e54:	b430      	push	{r4, r5}
	CHIP_CGU_BASE_CLK_T baseclk = CLK_BASE_NONE;
	int i = 0;
1a000e56:	2300      	movs	r3, #0
}

/* Finds the base clock for the peripheral clock */
static CHIP_CGU_BASE_CLK_T Chip_Clock_FindBaseClock(CHIP_CCU_CLK_T clk)
{
	CHIP_CGU_BASE_CLK_T baseclk = CLK_BASE_NONE;
1a000e58:	211c      	movs	r1, #28
	int i = 0;

	while ((baseclk == CLK_BASE_NONE) && (periph_to_base[i].clkbase != baseclk)) {
1a000e5a:	e010      	b.n	1a000e7e <Chip_Clock_FindBaseClock+0x2a>
		if ((clk >= periph_to_base[i].clkstart) && (clk <= periph_to_base[i].clkend)) {
1a000e5c:	eb03 0243 	add.w	r2, r3, r3, lsl #1
1a000e60:	0052      	lsls	r2, r2, #1
1a000e62:	4d0d      	ldr	r5, [pc, #52]	; (1a000e98 <Chip_Clock_FindBaseClock+0x44>)
1a000e64:	5aaa      	ldrh	r2, [r5, r2]
1a000e66:	4282      	cmp	r2, r0
1a000e68:	d806      	bhi.n	1a000e78 <Chip_Clock_FindBaseClock+0x24>
1a000e6a:	eb03 0243 	add.w	r2, r3, r3, lsl #1
1a000e6e:	0052      	lsls	r2, r2, #1
1a000e70:	442a      	add	r2, r5
1a000e72:	8852      	ldrh	r2, [r2, #2]
1a000e74:	4282      	cmp	r2, r0
1a000e76:	d201      	bcs.n	1a000e7c <Chip_Clock_FindBaseClock+0x28>
			baseclk = periph_to_base[i].clkbase;
		}
		else {
			i++;
1a000e78:	3301      	adds	r3, #1
1a000e7a:	e000      	b.n	1a000e7e <Chip_Clock_FindBaseClock+0x2a>
	CHIP_CGU_BASE_CLK_T baseclk = CLK_BASE_NONE;
	int i = 0;

	while ((baseclk == CLK_BASE_NONE) && (periph_to_base[i].clkbase != baseclk)) {
		if ((clk >= periph_to_base[i].clkstart) && (clk <= periph_to_base[i].clkend)) {
			baseclk = periph_to_base[i].clkbase;
1a000e7c:	4621      	mov	r1, r4
static CHIP_CGU_BASE_CLK_T Chip_Clock_FindBaseClock(CHIP_CCU_CLK_T clk)
{
	CHIP_CGU_BASE_CLK_T baseclk = CLK_BASE_NONE;
	int i = 0;

	while ((baseclk == CLK_BASE_NONE) && (periph_to_base[i].clkbase != baseclk)) {
1a000e7e:	291c      	cmp	r1, #28
1a000e80:	d107      	bne.n	1a000e92 <Chip_Clock_FindBaseClock+0x3e>
1a000e82:	eb03 0243 	add.w	r2, r3, r3, lsl #1
1a000e86:	0052      	lsls	r2, r2, #1
1a000e88:	4c03      	ldr	r4, [pc, #12]	; (1a000e98 <Chip_Clock_FindBaseClock+0x44>)
1a000e8a:	4422      	add	r2, r4
1a000e8c:	7914      	ldrb	r4, [r2, #4]
1a000e8e:	428c      	cmp	r4, r1
1a000e90:	d1e4      	bne.n	1a000e5c <Chip_Clock_FindBaseClock+0x8>
			i++;
		}
	}

	return baseclk;
}
1a000e92:	4608      	mov	r0, r1
1a000e94:	bc30      	pop	{r4, r5}
1a000e96:	4770      	bx	lr
1a000e98:	1a001d60 	.word	0x1a001d60

1a000e9c <Chip_Clock_EnableCrystal>:
 * Public functions
 ****************************************************************************/

/* Enables the crystal oscillator */
void Chip_Clock_EnableCrystal(void)
{
1a000e9c:	b082      	sub	sp, #8
	volatile uint32_t delay = 1000;
1a000e9e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
1a000ea2:	9301      	str	r3, [sp, #4]

	uint32_t OldCrystalConfig = LPC_CGU->XTAL_OSC_CTRL;
1a000ea4:	4a0d      	ldr	r2, [pc, #52]	; (1a000edc <Chip_Clock_EnableCrystal+0x40>)
1a000ea6:	6993      	ldr	r3, [r2, #24]

	/* Clear bypass mode */
	OldCrystalConfig &= (~2);
1a000ea8:	f023 0102 	bic.w	r1, r3, #2
	if (OldCrystalConfig != LPC_CGU->XTAL_OSC_CTRL) {
1a000eac:	6992      	ldr	r2, [r2, #24]
1a000eae:	428a      	cmp	r2, r1
1a000eb0:	d001      	beq.n	1a000eb6 <Chip_Clock_EnableCrystal+0x1a>
		LPC_CGU->XTAL_OSC_CTRL = OldCrystalConfig;
1a000eb2:	4a0a      	ldr	r2, [pc, #40]	; (1a000edc <Chip_Clock_EnableCrystal+0x40>)
1a000eb4:	6191      	str	r1, [r2, #24]
	}

	/* Enable crystal oscillator */
	OldCrystalConfig &= (~1);
1a000eb6:	f023 0303 	bic.w	r3, r3, #3
	if (OscRateIn >= 20000000) {
1a000eba:	4a09      	ldr	r2, [pc, #36]	; (1a000ee0 <Chip_Clock_EnableCrystal+0x44>)
1a000ebc:	6811      	ldr	r1, [r2, #0]
1a000ebe:	4a09      	ldr	r2, [pc, #36]	; (1a000ee4 <Chip_Clock_EnableCrystal+0x48>)
1a000ec0:	4291      	cmp	r1, r2
1a000ec2:	d901      	bls.n	1a000ec8 <Chip_Clock_EnableCrystal+0x2c>
		OldCrystalConfig |= 4;	/* Set high frequency mode */
1a000ec4:	f043 0304 	orr.w	r3, r3, #4

	}
	LPC_CGU->XTAL_OSC_CTRL = OldCrystalConfig;
1a000ec8:	4a04      	ldr	r2, [pc, #16]	; (1a000edc <Chip_Clock_EnableCrystal+0x40>)
1a000eca:	6193      	str	r3, [r2, #24]

	/* Delay for 250uSec */
	while(delay--) {}
1a000ecc:	9b01      	ldr	r3, [sp, #4]
1a000ece:	1e5a      	subs	r2, r3, #1
1a000ed0:	9201      	str	r2, [sp, #4]
1a000ed2:	2b00      	cmp	r3, #0
1a000ed4:	d1fa      	bne.n	1a000ecc <Chip_Clock_EnableCrystal+0x30>
}
1a000ed6:	b002      	add	sp, #8
1a000ed8:	4770      	bx	lr
1a000eda:	bf00      	nop
1a000edc:	40050000 	.word	0x40050000
1a000ee0:	1a001cb0 	.word	0x1a001cb0
1a000ee4:	01312cff 	.word	0x01312cff

1a000ee8 <Chip_Clock_GetDividerSource>:
}

/* Gets a CGU clock divider source */
CHIP_CGU_CLKIN_T Chip_Clock_GetDividerSource(CHIP_CGU_IDIV_T Divider)
{
	uint32_t reg = LPC_CGU->IDIV_CTRL[Divider];
1a000ee8:	3012      	adds	r0, #18
1a000eea:	4b05      	ldr	r3, [pc, #20]	; (1a000f00 <Chip_Clock_GetDividerSource+0x18>)
1a000eec:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]

	if (reg & 1) {	/* divider is powered down */
1a000ef0:	f010 0f01 	tst.w	r0, #1
1a000ef4:	d102      	bne.n	1a000efc <Chip_Clock_GetDividerSource+0x14>
		return CLKINPUT_PD;
	}

	return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
1a000ef6:	f3c0 6004 	ubfx	r0, r0, #24, #5
1a000efa:	4770      	bx	lr
CHIP_CGU_CLKIN_T Chip_Clock_GetDividerSource(CHIP_CGU_IDIV_T Divider)
{
	uint32_t reg = LPC_CGU->IDIV_CTRL[Divider];

	if (reg & 1) {	/* divider is powered down */
		return CLKINPUT_PD;
1a000efc:	2011      	movs	r0, #17
	}

	return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
}
1a000efe:	4770      	bx	lr
1a000f00:	40050000 	.word	0x40050000

1a000f04 <Chip_Clock_GetDividerDivisor>:

/* Gets a CGU clock divider divisor */
uint32_t Chip_Clock_GetDividerDivisor(CHIP_CGU_IDIV_T Divider)
{
	return (CHIP_CGU_CLKIN_T) ((LPC_CGU->IDIV_CTRL[Divider] >> 2) & CHIP_CGU_IDIV_MASK(Divider));
1a000f04:	f100 0212 	add.w	r2, r0, #18
1a000f08:	4b03      	ldr	r3, [pc, #12]	; (1a000f18 <Chip_Clock_GetDividerDivisor+0x14>)
1a000f0a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
1a000f0e:	4b03      	ldr	r3, [pc, #12]	; (1a000f1c <Chip_Clock_GetDividerDivisor+0x18>)
1a000f10:	5c18      	ldrb	r0, [r3, r0]
}
1a000f12:	ea00 0092 	and.w	r0, r0, r2, lsr #2
1a000f16:	4770      	bx	lr
1a000f18:	40050000 	.word	0x40050000
1a000f1c:	1a001d58 	.word	0x1a001d58

1a000f20 <Chip_Clock_GetClockInputHz>:

/* Returns the frequency of the specified input clock source */
uint32_t Chip_Clock_GetClockInputHz(CHIP_CGU_CLKIN_T input)
{
1a000f20:	b508      	push	{r3, lr}
	uint32_t rate = 0;

	switch (input) {
1a000f22:	2810      	cmp	r0, #16
1a000f24:	d80a      	bhi.n	1a000f3c <Chip_Clock_GetClockInputHz+0x1c>
1a000f26:	e8df f000 	tbb	[pc, r0]
1a000f2a:	0b42      	.short	0x0b42
1a000f2c:	091f160d 	.word	0x091f160d
1a000f30:	2b282522 	.word	0x2b282522
1a000f34:	322e0909 	.word	0x322e0909
1a000f38:	3a36      	.short	0x3a36
1a000f3a:	3e          	.byte	0x3e
1a000f3b:	00          	.byte	0x00
}

/* Returns the frequency of the specified input clock source */
uint32_t Chip_Clock_GetClockInputHz(CHIP_CGU_CLKIN_T input)
{
	uint32_t rate = 0;
1a000f3c:	2000      	movs	r0, #0
1a000f3e:	bd08      	pop	{r3, pc}
	case CLKIN_32K:
		rate = CRYSTAL_32K_FREQ_IN;
		break;

	case CLKIN_IRC:
		rate = CGU_IRC_FREQ;
1a000f40:	481e      	ldr	r0, [pc, #120]	; (1a000fbc <Chip_Clock_GetClockInputHz+0x9c>)
		break;
1a000f42:	bd08      	pop	{r3, pc}

	case CLKIN_ENET_RX:
		if ((LPC_CREG->CREG6 & 0x07) != 0x4) {
1a000f44:	4b1e      	ldr	r3, [pc, #120]	; (1a000fc0 <Chip_Clock_GetClockInputHz+0xa0>)
1a000f46:	f8d3 312c 	ldr.w	r3, [r3, #300]	; 0x12c
1a000f4a:	f003 0307 	and.w	r3, r3, #7
1a000f4e:	2b04      	cmp	r3, #4
1a000f50:	d130      	bne.n	1a000fb4 <Chip_Clock_GetClockInputHz+0x94>
}

/* Returns the frequency of the specified input clock source */
uint32_t Chip_Clock_GetClockInputHz(CHIP_CGU_CLKIN_T input)
{
	uint32_t rate = 0;
1a000f52:	2000      	movs	r0, #0
1a000f54:	bd08      	pop	{r3, pc}
			rate = 25000000;
		}
		break;

	case CLKIN_ENET_TX:
		if ((LPC_CREG->CREG6 & 0x07) != 0x4) {
1a000f56:	4b1a      	ldr	r3, [pc, #104]	; (1a000fc0 <Chip_Clock_GetClockInputHz+0xa0>)
1a000f58:	f8d3 312c 	ldr.w	r3, [r3, #300]	; 0x12c
1a000f5c:	f003 0307 	and.w	r3, r3, #7
1a000f60:	2b04      	cmp	r3, #4
1a000f62:	d029      	beq.n	1a000fb8 <Chip_Clock_GetClockInputHz+0x98>
			rate = 25000000; /* MII uses 25 MHz */
1a000f64:	4817      	ldr	r0, [pc, #92]	; (1a000fc4 <Chip_Clock_GetClockInputHz+0xa4>)
1a000f66:	bd08      	pop	{r3, pc}
			rate = 50000000; /* RMII uses 50 MHz */
		}
		break;

	case CLKIN_CLKIN:
		rate = ExtRateIn;
1a000f68:	4b17      	ldr	r3, [pc, #92]	; (1a000fc8 <Chip_Clock_GetClockInputHz+0xa8>)
1a000f6a:	6818      	ldr	r0, [r3, #0]
		break;
1a000f6c:	bd08      	pop	{r3, pc}

	case CLKIN_CRYSTAL:
		rate = OscRateIn;
1a000f6e:	4b17      	ldr	r3, [pc, #92]	; (1a000fcc <Chip_Clock_GetClockInputHz+0xac>)
1a000f70:	6818      	ldr	r0, [r3, #0]
		break;
1a000f72:	bd08      	pop	{r3, pc}

	case CLKIN_USBPLL:
		rate = audio_usb_pll_freq[CGU_USB_PLL];
1a000f74:	4b16      	ldr	r3, [pc, #88]	; (1a000fd0 <Chip_Clock_GetClockInputHz+0xb0>)
1a000f76:	6818      	ldr	r0, [r3, #0]
		break;
1a000f78:	bd08      	pop	{r3, pc}

	case CLKIN_AUDIOPLL:
		rate = audio_usb_pll_freq[CGU_AUDIO_PLL];
1a000f7a:	4b15      	ldr	r3, [pc, #84]	; (1a000fd0 <Chip_Clock_GetClockInputHz+0xb0>)
1a000f7c:	6858      	ldr	r0, [r3, #4]
		break;
1a000f7e:	bd08      	pop	{r3, pc}

	case CLKIN_MAINPLL:
		rate = Chip_Clock_GetMainPLLHz();
1a000f80:	f000 f86a 	bl	1a001058 <Chip_Clock_GetMainPLLHz>
		break;
1a000f84:	bd08      	pop	{r3, pc}

	case CLKIN_IDIVA:
		rate = Chip_Clock_GetDivRate(input, CLK_IDIV_A);
1a000f86:	2100      	movs	r1, #0
1a000f88:	f000 f89a 	bl	1a0010c0 <Chip_Clock_GetDivRate>
		break;
1a000f8c:	bd08      	pop	{r3, pc}

	case CLKIN_IDIVB:
		rate = Chip_Clock_GetDivRate(input, CLK_IDIV_B);
1a000f8e:	2101      	movs	r1, #1
1a000f90:	f000 f896 	bl	1a0010c0 <Chip_Clock_GetDivRate>
		break;
1a000f94:	bd08      	pop	{r3, pc}

	case CLKIN_IDIVC:
		rate = Chip_Clock_GetDivRate(input, CLK_IDIV_C);
1a000f96:	2102      	movs	r1, #2
1a000f98:	f000 f892 	bl	1a0010c0 <Chip_Clock_GetDivRate>
		break;
1a000f9c:	bd08      	pop	{r3, pc}

	case CLKIN_IDIVD:
		rate = Chip_Clock_GetDivRate(input, CLK_IDIV_D);
1a000f9e:	2103      	movs	r1, #3
1a000fa0:	f000 f88e 	bl	1a0010c0 <Chip_Clock_GetDivRate>
		break;
1a000fa4:	bd08      	pop	{r3, pc}

	case CLKIN_IDIVE:
		rate = Chip_Clock_GetDivRate(input, CLK_IDIV_E);
1a000fa6:	2104      	movs	r1, #4
1a000fa8:	f000 f88a 	bl	1a0010c0 <Chip_Clock_GetDivRate>
		break;
1a000fac:	bd08      	pop	{r3, pc}
{
	uint32_t rate = 0;

	switch (input) {
	case CLKIN_32K:
		rate = CRYSTAL_32K_FREQ_IN;
1a000fae:	f44f 4000 	mov.w	r0, #32768	; 0x8000
1a000fb2:	bd08      	pop	{r3, pc}
		break;

	case CLKIN_ENET_RX:
		if ((LPC_CREG->CREG6 & 0x07) != 0x4) {
			/* MII mode requires 25MHz clock */
			rate = 25000000;
1a000fb4:	4803      	ldr	r0, [pc, #12]	; (1a000fc4 <Chip_Clock_GetClockInputHz+0xa4>)
1a000fb6:	bd08      	pop	{r3, pc}

	case CLKIN_ENET_TX:
		if ((LPC_CREG->CREG6 & 0x07) != 0x4) {
			rate = 25000000; /* MII uses 25 MHz */
		} else {
			rate = 50000000; /* RMII uses 50 MHz */
1a000fb8:	4806      	ldr	r0, [pc, #24]	; (1a000fd4 <Chip_Clock_GetClockInputHz+0xb4>)
	default:
		break;
	}

	return rate;
}
1a000fba:	bd08      	pop	{r3, pc}
1a000fbc:	00b71b00 	.word	0x00b71b00
1a000fc0:	40043000 	.word	0x40043000
1a000fc4:	017d7840 	.word	0x017d7840
1a000fc8:	1a001cb4 	.word	0x1a001cb4
1a000fcc:	1a001cb0 	.word	0x1a001cb0
1a000fd0:	100000a0 	.word	0x100000a0
1a000fd4:	02faf080 	.word	0x02faf080

1a000fd8 <Chip_Clock_CalcMainPLLValue>:
	while(delay--) {}
}

/* Calculate the Main PLL div values */
int Chip_Clock_CalcMainPLLValue(uint32_t freq, PLL_PARAM_T *ppll)
{
1a000fd8:	b538      	push	{r3, r4, r5, lr}
1a000fda:	4605      	mov	r5, r0
1a000fdc:	460c      	mov	r4, r1
	ppll->fin = Chip_Clock_GetClockInputHz(ppll->srcin);
1a000fde:	7908      	ldrb	r0, [r1, #4]
1a000fe0:	f7ff ff9e 	bl	1a000f20 <Chip_Clock_GetClockInputHz>
1a000fe4:	6160      	str	r0, [r4, #20]

	/* Do sanity check on frequency */
	if (freq > MAX_CLOCK_FREQ || freq < (PLL_MIN_CCO_FREQ / 16) || !ppll->fin) {
1a000fe6:	4b19      	ldr	r3, [pc, #100]	; (1a00104c <Chip_Clock_CalcMainPLLValue+0x74>)
1a000fe8:	442b      	add	r3, r5
1a000fea:	4a19      	ldr	r2, [pc, #100]	; (1a001050 <Chip_Clock_CalcMainPLLValue+0x78>)
1a000fec:	4293      	cmp	r3, r2
1a000fee:	d821      	bhi.n	1a001034 <Chip_Clock_CalcMainPLLValue+0x5c>
1a000ff0:	b318      	cbz	r0, 1a00103a <Chip_Clock_CalcMainPLLValue+0x62>
		return -1;
	}

	ppll->ctrl = 1 << 7; /* Enable direct mode [If possible] */
1a000ff2:	2380      	movs	r3, #128	; 0x80
1a000ff4:	6023      	str	r3, [r4, #0]
	ppll->nsel = 0;
1a000ff6:	2300      	movs	r3, #0
1a000ff8:	60a3      	str	r3, [r4, #8]
	ppll->psel = 0;
1a000ffa:	60e3      	str	r3, [r4, #12]
	ppll->msel = freq / ppll->fin;
1a000ffc:	fbb5 f3f0 	udiv	r3, r5, r0
1a001000:	6123      	str	r3, [r4, #16]

	if (freq < PLL_MIN_CCO_FREQ || ppll->msel * ppll->fin != freq) {
1a001002:	4a14      	ldr	r2, [pc, #80]	; (1a001054 <Chip_Clock_CalcMainPLLValue+0x7c>)
1a001004:	4295      	cmp	r5, r2
1a001006:	d903      	bls.n	1a001010 <Chip_Clock_CalcMainPLLValue+0x38>
1a001008:	fb03 f000 	mul.w	r0, r3, r0
1a00100c:	42a8      	cmp	r0, r5
1a00100e:	d007      	beq.n	1a001020 <Chip_Clock_CalcMainPLLValue+0x48>
		pll_get_frac(freq, ppll);
1a001010:	4628      	mov	r0, r5
1a001012:	4621      	mov	r1, r4
1a001014:	f7ff fe9c 	bl	1a000d50 <pll_get_frac>
		if (!ppll->nsel) {
1a001018:	68a3      	ldr	r3, [r4, #8]
1a00101a:	b18b      	cbz	r3, 1a001040 <Chip_Clock_CalcMainPLLValue+0x68>
			return -1;
		}
		ppll->nsel --;
1a00101c:	3b01      	subs	r3, #1
1a00101e:	60a3      	str	r3, [r4, #8]
	}

	if (ppll->msel == 0) {
1a001020:	6923      	ldr	r3, [r4, #16]
1a001022:	b183      	cbz	r3, 1a001046 <Chip_Clock_CalcMainPLLValue+0x6e>
		return - 1;
	}

	if (ppll->psel) {
1a001024:	68e2      	ldr	r2, [r4, #12]
1a001026:	b10a      	cbz	r2, 1a00102c <Chip_Clock_CalcMainPLLValue+0x54>
		ppll->psel --;
1a001028:	3a01      	subs	r2, #1
1a00102a:	60e2      	str	r2, [r4, #12]
	}

	ppll->msel --;
1a00102c:	3b01      	subs	r3, #1
1a00102e:	6123      	str	r3, [r4, #16]

	return 0;
1a001030:	2000      	movs	r0, #0
1a001032:	bd38      	pop	{r3, r4, r5, pc}
{
	ppll->fin = Chip_Clock_GetClockInputHz(ppll->srcin);

	/* Do sanity check on frequency */
	if (freq > MAX_CLOCK_FREQ || freq < (PLL_MIN_CCO_FREQ / 16) || !ppll->fin) {
		return -1;
1a001034:	f04f 30ff 	mov.w	r0, #4294967295
1a001038:	bd38      	pop	{r3, r4, r5, pc}
1a00103a:	f04f 30ff 	mov.w	r0, #4294967295
1a00103e:	bd38      	pop	{r3, r4, r5, pc}
	ppll->msel = freq / ppll->fin;

	if (freq < PLL_MIN_CCO_FREQ || ppll->msel * ppll->fin != freq) {
		pll_get_frac(freq, ppll);
		if (!ppll->nsel) {
			return -1;
1a001040:	f04f 30ff 	mov.w	r0, #4294967295
1a001044:	bd38      	pop	{r3, r4, r5, pc}
		}
		ppll->nsel --;
	}

	if (ppll->msel == 0) {
		return - 1;
1a001046:	f04f 30ff 	mov.w	r0, #4294967295
	}

	ppll->msel --;

	return 0;
}
1a00104a:	bd38      	pop	{r3, r4, r5, pc}
1a00104c:	ff6b3a10 	.word	0xff6b3a10
1a001050:	0b940510 	.word	0x0b940510
1a001054:	094c5eff 	.word	0x094c5eff

1a001058 <Chip_Clock_GetMainPLLHz>:
	return freq;
}

/* Returns the frequency of the main PLL */
uint32_t Chip_Clock_GetMainPLLHz(void)
{
1a001058:	b570      	push	{r4, r5, r6, lr}
1a00105a:	b082      	sub	sp, #8
	uint32_t PLLReg = LPC_CGU->PLL1_CTRL;
1a00105c:	4d16      	ldr	r5, [pc, #88]	; (1a0010b8 <Chip_Clock_GetMainPLLHz+0x60>)
1a00105e:	6c6c      	ldr	r4, [r5, #68]	; 0x44
	uint32_t freq = Chip_Clock_GetClockInputHz((CHIP_CGU_CLKIN_T) ((PLLReg >> 24) & 0xF));
1a001060:	f3c4 6003 	ubfx	r0, r4, #24, #4
1a001064:	f7ff ff5c 	bl	1a000f20 <Chip_Clock_GetClockInputHz>
1a001068:	4606      	mov	r6, r0
	uint32_t msel, nsel, psel, direct, fbsel;
	uint32_t m, n, p;
	const uint8_t ptab[] = {1, 2, 4, 8};
1a00106a:	4b14      	ldr	r3, [pc, #80]	; (1a0010bc <Chip_Clock_GetMainPLLHz+0x64>)
1a00106c:	6818      	ldr	r0, [r3, #0]
1a00106e:	9001      	str	r0, [sp, #4]

	/* No lock? */
	if (!(LPC_CGU->PLL1_STAT & 1)) {
1a001070:	6c28      	ldr	r0, [r5, #64]	; 0x40
1a001072:	f010 0001 	ands.w	r0, r0, #1
1a001076:	d01d      	beq.n	1a0010b4 <Chip_Clock_GetMainPLLHz+0x5c>
		return 0;
	}

	msel = (PLLReg >> 16) & 0xFF;
1a001078:	f3c4 4007 	ubfx	r0, r4, #16, #8
	nsel = (PLLReg >> 12) & 0x3;
1a00107c:	f3c4 3201 	ubfx	r2, r4, #12, #2
	psel = (PLLReg >> 8) & 0x3;
1a001080:	f3c4 2101 	ubfx	r1, r4, #8, #2
	direct = (PLLReg >> 7) & 0x1;
	fbsel = (PLLReg >> 6) & 0x1;
1a001084:	f3c4 1580 	ubfx	r5, r4, #6, #1

	m = msel + 1;
1a001088:	1c43      	adds	r3, r0, #1
	n = nsel + 1;
1a00108a:	3201      	adds	r2, #1
	p = ptab[psel];
1a00108c:	a802      	add	r0, sp, #8
1a00108e:	4401      	add	r1, r0
1a001090:	f811 0c04 	ldrb.w	r0, [r1, #-4]

	if (direct || fbsel) {
1a001094:	f014 0f80 	tst.w	r4, #128	; 0x80
1a001098:	d100      	bne.n	1a00109c <Chip_Clock_GetMainPLLHz+0x44>
1a00109a:	b125      	cbz	r5, 1a0010a6 <Chip_Clock_GetMainPLLHz+0x4e>
		return m * (freq / n);
1a00109c:	fbb6 f0f2 	udiv	r0, r6, r2
1a0010a0:	fb03 f000 	mul.w	r0, r3, r0
1a0010a4:	e006      	b.n	1a0010b4 <Chip_Clock_GetMainPLLHz+0x5c>
	}

	return (m / (2 * p)) * (freq / n);
1a0010a6:	0040      	lsls	r0, r0, #1
1a0010a8:	fbb3 f3f0 	udiv	r3, r3, r0
1a0010ac:	fbb6 f0f2 	udiv	r0, r6, r2
1a0010b0:	fb00 f003 	mul.w	r0, r0, r3
}
1a0010b4:	b002      	add	sp, #8
1a0010b6:	bd70      	pop	{r4, r5, r6, pc}
1a0010b8:	40050000 	.word	0x40050000
1a0010bc:	1a001d54 	.word	0x1a001d54

1a0010c0 <Chip_Clock_GetDivRate>:
	return TestHz;
}

/* Returns clock rate out of a divider */
static uint32_t Chip_Clock_GetDivRate(CHIP_CGU_CLKIN_T clock, CHIP_CGU_IDIV_T divider)
{
1a0010c0:	b538      	push	{r3, r4, r5, lr}
1a0010c2:	460c      	mov	r4, r1
	CHIP_CGU_CLKIN_T input;
	uint32_t div;

	input = Chip_Clock_GetDividerSource(divider);
1a0010c4:	4608      	mov	r0, r1
1a0010c6:	f7ff ff0f 	bl	1a000ee8 <Chip_Clock_GetDividerSource>
1a0010ca:	4605      	mov	r5, r0
	div = Chip_Clock_GetDividerDivisor(divider);
1a0010cc:	4620      	mov	r0, r4
1a0010ce:	f7ff ff19 	bl	1a000f04 <Chip_Clock_GetDividerDivisor>
1a0010d2:	4604      	mov	r4, r0
	return Chip_Clock_GetClockInputHz(input) / (div + 1);
1a0010d4:	4628      	mov	r0, r5
1a0010d6:	f7ff ff23 	bl	1a000f20 <Chip_Clock_GetClockInputHz>
1a0010da:	3401      	adds	r4, #1
}
1a0010dc:	fbb0 f0f4 	udiv	r0, r0, r4
1a0010e0:	bd38      	pop	{r3, r4, r5, pc}
1a0010e2:	bf00      	nop

1a0010e4 <Chip_Clock_SetBaseClock>:
	return Chip_Clock_GetClockInputHz(Chip_Clock_GetBaseClock(clock));
}

/* Sets a CGU Base Clock clock source */
void Chip_Clock_SetBaseClock(CHIP_CGU_BASE_CLK_T BaseClock, CHIP_CGU_CLKIN_T Input, bool autoblocken, bool powerdn)
{
1a0010e4:	b430      	push	{r4, r5}
	uint32_t reg = LPC_CGU->BASE_CLK[BaseClock];
1a0010e6:	0085      	lsls	r5, r0, #2
1a0010e8:	4c0d      	ldr	r4, [pc, #52]	; (1a001120 <Chip_Clock_SetBaseClock+0x3c>)
1a0010ea:	5965      	ldr	r5, [r4, r5]

	if (BaseClock < CLK_BASE_NONE) {
1a0010ec:	281b      	cmp	r0, #27
1a0010ee:	d80f      	bhi.n	1a001110 <Chip_Clock_SetBaseClock+0x2c>
		if (Input != CLKINPUT_PD) {
1a0010f0:	2911      	cmp	r1, #17
1a0010f2:	d012      	beq.n	1a00111a <Chip_Clock_SetBaseClock+0x36>
			/* Mask off fields we plan to update */
			reg &= ~((0x1F << 24) | 1 | (1 << 11));
1a0010f4:	4c0b      	ldr	r4, [pc, #44]	; (1a001124 <Chip_Clock_SetBaseClock+0x40>)
1a0010f6:	402c      	ands	r4, r5

			if (autoblocken) {
1a0010f8:	b10a      	cbz	r2, 1a0010fe <Chip_Clock_SetBaseClock+0x1a>
				reg |= (1 << 11);
1a0010fa:	f444 6400 	orr.w	r4, r4, #2048	; 0x800
			}
			if (powerdn) {
1a0010fe:	b10b      	cbz	r3, 1a001104 <Chip_Clock_SetBaseClock+0x20>
				reg |= (1 << 0);
1a001100:	f044 0401 	orr.w	r4, r4, #1
			}

			/* Set clock source */
			reg |= (Input << 24);
1a001104:	ea44 6401 	orr.w	r4, r4, r1, lsl #24

			LPC_CGU->BASE_CLK[BaseClock] = reg;
1a001108:	0080      	lsls	r0, r0, #2
1a00110a:	4b05      	ldr	r3, [pc, #20]	; (1a001120 <Chip_Clock_SetBaseClock+0x3c>)
1a00110c:	501c      	str	r4, [r3, r0]
1a00110e:	e004      	b.n	1a00111a <Chip_Clock_SetBaseClock+0x36>
		}
	}
	else {
		LPC_CGU->BASE_CLK[BaseClock] = reg | 1;	/* Power down this base clock */
1a001110:	f045 0501 	orr.w	r5, r5, #1
1a001114:	0080      	lsls	r0, r0, #2
1a001116:	4b02      	ldr	r3, [pc, #8]	; (1a001120 <Chip_Clock_SetBaseClock+0x3c>)
1a001118:	501d      	str	r5, [r3, r0]
	}
}
1a00111a:	bc30      	pop	{r4, r5}
1a00111c:	4770      	bx	lr
1a00111e:	bf00      	nop
1a001120:	4005005c 	.word	0x4005005c
1a001124:	e0fff7fe 	.word	0xe0fff7fe

1a001128 <Chip_Clock_EnableBaseClock>:
}

/*Enables a base clock source */
void Chip_Clock_EnableBaseClock(CHIP_CGU_BASE_CLK_T BaseClock)
{
	if (BaseClock < CLK_BASE_NONE) {
1a001128:	281b      	cmp	r0, #27
1a00112a:	d805      	bhi.n	1a001138 <Chip_Clock_EnableBaseClock+0x10>
		LPC_CGU->BASE_CLK[BaseClock] &= ~1;
1a00112c:	0080      	lsls	r0, r0, #2
1a00112e:	4b03      	ldr	r3, [pc, #12]	; (1a00113c <Chip_Clock_EnableBaseClock+0x14>)
1a001130:	581a      	ldr	r2, [r3, r0]
1a001132:	f022 0201 	bic.w	r2, r2, #1
1a001136:	501a      	str	r2, [r3, r0]
1a001138:	4770      	bx	lr
1a00113a:	bf00      	nop
1a00113c:	4005005c 	.word	0x4005005c

1a001140 <Chip_Clock_GetBaseClock>:
/* Gets a CGU Base Clock clock source */
CHIP_CGU_CLKIN_T Chip_Clock_GetBaseClock(CHIP_CGU_BASE_CLK_T BaseClock)
{
	uint32_t reg;

	if (BaseClock >= CLK_BASE_NONE) {
1a001140:	281b      	cmp	r0, #27
1a001142:	d808      	bhi.n	1a001156 <Chip_Clock_GetBaseClock+0x16>
		return CLKINPUT_PD;
	}

	reg = LPC_CGU->BASE_CLK[BaseClock];
1a001144:	0080      	lsls	r0, r0, #2
1a001146:	4b06      	ldr	r3, [pc, #24]	; (1a001160 <Chip_Clock_GetBaseClock+0x20>)
1a001148:	5818      	ldr	r0, [r3, r0]

	/* base clock is powered down? */
	if (reg & 1) {
1a00114a:	f010 0f01 	tst.w	r0, #1
1a00114e:	d104      	bne.n	1a00115a <Chip_Clock_GetBaseClock+0x1a>
		return CLKINPUT_PD;
	}

	return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
1a001150:	f3c0 6004 	ubfx	r0, r0, #24, #5
1a001154:	4770      	bx	lr
CHIP_CGU_CLKIN_T Chip_Clock_GetBaseClock(CHIP_CGU_BASE_CLK_T BaseClock)
{
	uint32_t reg;

	if (BaseClock >= CLK_BASE_NONE) {
		return CLKINPUT_PD;
1a001156:	2011      	movs	r0, #17
1a001158:	4770      	bx	lr

	reg = LPC_CGU->BASE_CLK[BaseClock];

	/* base clock is powered down? */
	if (reg & 1) {
		return CLKINPUT_PD;
1a00115a:	2011      	movs	r0, #17
	}

	return (CHIP_CGU_CLKIN_T) ((reg >> 24) & 0x1F);
}
1a00115c:	4770      	bx	lr
1a00115e:	bf00      	nop
1a001160:	4005005c 	.word	0x4005005c

1a001164 <Chip_Clock_GetBaseClocktHz>:
	return rate;
}

/* Returns the frequency of the specified base clock source */
uint32_t Chip_Clock_GetBaseClocktHz(CHIP_CGU_BASE_CLK_T clock)
{
1a001164:	b508      	push	{r3, lr}
	return Chip_Clock_GetClockInputHz(Chip_Clock_GetBaseClock(clock));
1a001166:	f7ff ffeb 	bl	1a001140 <Chip_Clock_GetBaseClock>
1a00116a:	f7ff fed9 	bl	1a000f20 <Chip_Clock_GetClockInputHz>
}
1a00116e:	bd08      	pop	{r3, pc}

1a001170 <Chip_Clock_EnableOpts>:
/* Enables a peripheral clock and sets clock states */
void Chip_Clock_EnableOpts(CHIP_CCU_CLK_T clk, bool autoen, bool wakeupen, int div)
{
	uint32_t reg = 1;

	if (autoen) {
1a001170:	b909      	cbnz	r1, 1a001176 <Chip_Clock_EnableOpts+0x6>
}

/* Enables a peripheral clock and sets clock states */
void Chip_Clock_EnableOpts(CHIP_CCU_CLK_T clk, bool autoen, bool wakeupen, int div)
{
	uint32_t reg = 1;
1a001172:	2101      	movs	r1, #1
1a001174:	e000      	b.n	1a001178 <Chip_Clock_EnableOpts+0x8>

	if (autoen) {
		reg |= (1 << 1);
1a001176:	2103      	movs	r1, #3
	}
	if (wakeupen) {
1a001178:	b10a      	cbz	r2, 1a00117e <Chip_Clock_EnableOpts+0xe>
		reg |= (1 << 2);
1a00117a:	f041 0104 	orr.w	r1, r1, #4
	}

	/* Not all clocks support a divider, but we won't check that here. Only
	   dividers of 1 and 2 are allowed. Assume 1 if not 2 */
	if (div == 2) {
1a00117e:	2b02      	cmp	r3, #2
1a001180:	d101      	bne.n	1a001186 <Chip_Clock_EnableOpts+0x16>
		reg |= (1 << 5);
1a001182:	f041 0120 	orr.w	r1, r1, #32
	}

	/* Setup peripheral clock and start running */
	if (clk >= CLK_CCU2_START) {
1a001186:	f5b0 7fa1 	cmp.w	r0, #322	; 0x142
1a00118a:	d305      	bcc.n	1a001198 <Chip_Clock_EnableOpts+0x28>
		LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG = reg;
1a00118c:	f5a0 7091 	sub.w	r0, r0, #290	; 0x122
1a001190:	4b04      	ldr	r3, [pc, #16]	; (1a0011a4 <Chip_Clock_EnableOpts+0x34>)
1a001192:	f843 1030 	str.w	r1, [r3, r0, lsl #3]
1a001196:	4770      	bx	lr
	}
	else {
		LPC_CCU1->CLKCCU[clk].CFG = reg;
1a001198:	3020      	adds	r0, #32
1a00119a:	4b03      	ldr	r3, [pc, #12]	; (1a0011a8 <Chip_Clock_EnableOpts+0x38>)
1a00119c:	f843 1030 	str.w	r1, [r3, r0, lsl #3]
1a0011a0:	4770      	bx	lr
1a0011a2:	bf00      	nop
1a0011a4:	40052000 	.word	0x40052000
1a0011a8:	40051000 	.word	0x40051000

1a0011ac <Chip_Clock_Enable>:

/* Enables a peripheral clock */
void Chip_Clock_Enable(CHIP_CCU_CLK_T clk)
{
	/* Start peripheral clock running */
	if (clk >= CLK_CCU2_START) {
1a0011ac:	f5b0 7fa1 	cmp.w	r0, #322	; 0x142
1a0011b0:	d309      	bcc.n	1a0011c6 <Chip_Clock_Enable+0x1a>
		LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG |= 1;
1a0011b2:	4a09      	ldr	r2, [pc, #36]	; (1a0011d8 <Chip_Clock_Enable+0x2c>)
1a0011b4:	f5a0 7091 	sub.w	r0, r0, #290	; 0x122
1a0011b8:	f852 3030 	ldr.w	r3, [r2, r0, lsl #3]
1a0011bc:	f043 0301 	orr.w	r3, r3, #1
1a0011c0:	f842 3030 	str.w	r3, [r2, r0, lsl #3]
1a0011c4:	4770      	bx	lr
	}
	else {
		LPC_CCU1->CLKCCU[clk].CFG |= 1;
1a0011c6:	4a05      	ldr	r2, [pc, #20]	; (1a0011dc <Chip_Clock_Enable+0x30>)
1a0011c8:	3020      	adds	r0, #32
1a0011ca:	f852 3030 	ldr.w	r3, [r2, r0, lsl #3]
1a0011ce:	f043 0301 	orr.w	r3, r3, #1
1a0011d2:	f842 3030 	str.w	r3, [r2, r0, lsl #3]
1a0011d6:	4770      	bx	lr
1a0011d8:	40052000 	.word	0x40052000
1a0011dc:	40051000 	.word	0x40051000

1a0011e0 <Chip_Clock_GetRate>:
	LPC_CCU2->PM = 0;
}

/* Returns a peripheral clock rate */
uint32_t Chip_Clock_GetRate(CHIP_CCU_CLK_T clk)
{
1a0011e0:	b510      	push	{r4, lr}
	CHIP_CGU_BASE_CLK_T baseclk;
	uint32_t reg, div, rate;

	/* Get CCU config register for clock */
	if (clk >= CLK_CCU2_START) {
1a0011e2:	f5b0 7fa1 	cmp.w	r0, #322	; 0x142
1a0011e6:	d305      	bcc.n	1a0011f4 <Chip_Clock_GetRate+0x14>
		reg = LPC_CCU2->CLKCCU[clk - CLK_CCU2_START].CFG;
1a0011e8:	f5a0 7391 	sub.w	r3, r0, #290	; 0x122
1a0011ec:	4a0d      	ldr	r2, [pc, #52]	; (1a001224 <Chip_Clock_GetRate+0x44>)
1a0011ee:	f852 4033 	ldr.w	r4, [r2, r3, lsl #3]
1a0011f2:	e004      	b.n	1a0011fe <Chip_Clock_GetRate+0x1e>
	}
	else {
		reg = LPC_CCU1->CLKCCU[clk].CFG;
1a0011f4:	f100 0320 	add.w	r3, r0, #32
1a0011f8:	4a0b      	ldr	r2, [pc, #44]	; (1a001228 <Chip_Clock_GetRate+0x48>)
1a0011fa:	f852 4033 	ldr.w	r4, [r2, r3, lsl #3]
	}

	/* Is the clock enabled? */
	if (reg & 1) {
1a0011fe:	f014 0f01 	tst.w	r4, #1
1a001202:	d00c      	beq.n	1a00121e <Chip_Clock_GetRate+0x3e>
		/* Get base clock for this peripheral clock */
		baseclk = Chip_Clock_FindBaseClock(clk);
1a001204:	f7ff fe26 	bl	1a000e54 <Chip_Clock_FindBaseClock>

		/* Get base clock rate */
		rate = Chip_Clock_GetBaseClocktHz(baseclk);
1a001208:	f7ff ffac 	bl	1a001164 <Chip_Clock_GetBaseClocktHz>

		/* Get divider for this clock */
		if (((reg >> 5) & 0x7) == 0) {
1a00120c:	f014 0fe0 	tst.w	r4, #224	; 0xe0
1a001210:	d101      	bne.n	1a001216 <Chip_Clock_GetRate+0x36>
			div = 1;
1a001212:	2301      	movs	r3, #1
1a001214:	e000      	b.n	1a001218 <Chip_Clock_GetRate+0x38>
		}
		else {
			div = 2;/* No other dividers supported */
1a001216:	2302      	movs	r3, #2

		}
		rate = rate / div;
1a001218:	fbb0 f0f3 	udiv	r0, r0, r3
1a00121c:	bd10      	pop	{r4, pc}
	}
	else {
		rate = 0;
1a00121e:	2000      	movs	r0, #0
	}

	return rate;
}
1a001220:	bd10      	pop	{r4, pc}
1a001222:	bf00      	nop
1a001224:	40052000 	.word	0x40052000
1a001228:	40051000 	.word	0x40051000

1a00122c <Chip_Clock_SetupPLL>:
}

/* Sets up the audio or USB PLL */
void Chip_Clock_SetupPLL(CHIP_CGU_CLKIN_T Input, CHIP_CGU_USB_AUDIO_PLL_T pllnum,
						 const CGU_USBAUDIO_PLL_SETUP_T *pPLLSetup)
{
1a00122c:	b410      	push	{r4}
	uint32_t reg = pPLLSetup->ctrl | (Input << 24);
1a00122e:	6813      	ldr	r3, [r2, #0]
1a001230:	ea43 6000 	orr.w	r0, r3, r0, lsl #24

	/* Setup from passed values */
	LPC_CGU->PLL[pllnum].PLL_CTRL = reg;
1a001234:	4b0b      	ldr	r3, [pc, #44]	; (1a001264 <Chip_Clock_SetupPLL+0x38>)
1a001236:	eb03 1401 	add.w	r4, r3, r1, lsl #4
1a00123a:	6220      	str	r0, [r4, #32]
	LPC_CGU->PLL[pllnum].PLL_MDIV = pPLLSetup->mdiv;
1a00123c:	6850      	ldr	r0, [r2, #4]
1a00123e:	1c8c      	adds	r4, r1, #2
1a001240:	eb03 1304 	add.w	r3, r3, r4, lsl #4
1a001244:	6058      	str	r0, [r3, #4]
	LPC_CGU->PLL[pllnum].PLL_NP_DIV = pPLLSetup->ndiv;
1a001246:	6890      	ldr	r0, [r2, #8]
1a001248:	6098      	str	r0, [r3, #8]

	/* Fractional divider is for audio PLL only */
	if (pllnum == CGU_AUDIO_PLL) {
1a00124a:	2901      	cmp	r1, #1
1a00124c:	d102      	bne.n	1a001254 <Chip_Clock_SetupPLL+0x28>
		LPC_CGU->PLL0AUDIO_FRAC = pPLLSetup->fract;
1a00124e:	68d0      	ldr	r0, [r2, #12]
1a001250:	4b04      	ldr	r3, [pc, #16]	; (1a001264 <Chip_Clock_SetupPLL+0x38>)
1a001252:	63d8      	str	r0, [r3, #60]	; 0x3c
	}
	audio_usb_pll_freq[pllnum] = pPLLSetup->freq;
1a001254:	6912      	ldr	r2, [r2, #16]
1a001256:	4b04      	ldr	r3, [pc, #16]	; (1a001268 <Chip_Clock_SetupPLL+0x3c>)
1a001258:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
}
1a00125c:	f85d 4b04 	ldr.w	r4, [sp], #4
1a001260:	4770      	bx	lr
1a001262:	bf00      	nop
1a001264:	40050000 	.word	0x40050000
1a001268:	100000a0 	.word	0x100000a0

1a00126c <Chip_Clock_EnablePLL>:

/* Enables the audio or USB PLL */
void Chip_Clock_EnablePLL(CHIP_CGU_USB_AUDIO_PLL_T pllnum)
{
	LPC_CGU->PLL[pllnum].PLL_CTRL &= ~1;
1a00126c:	0100      	lsls	r0, r0, #4
1a00126e:	4b03      	ldr	r3, [pc, #12]	; (1a00127c <Chip_Clock_EnablePLL+0x10>)
1a001270:	581a      	ldr	r2, [r3, r0]
1a001272:	f022 0201 	bic.w	r2, r2, #1
1a001276:	501a      	str	r2, [r3, r0]
1a001278:	4770      	bx	lr
1a00127a:	bf00      	nop
1a00127c:	40050020 	.word	0x40050020

1a001280 <Chip_Clock_GetPLLStatus>:
}

/* Returns the PLL status */
uint32_t Chip_Clock_GetPLLStatus(CHIP_CGU_USB_AUDIO_PLL_T pllnum)
{
	return LPC_CGU->PLL[pllnum].PLL_STAT;
1a001280:	0100      	lsls	r0, r0, #4
1a001282:	4b01      	ldr	r3, [pc, #4]	; (1a001288 <Chip_Clock_GetPLLStatus+0x8>)
1a001284:	5818      	ldr	r0, [r3, r0]
}
1a001286:	4770      	bx	lr
1a001288:	4005001c 	.word	0x4005001c

1a00128c <Chip_USB_PllSetup>:
/*****************************************************************************
 * Private functions
 ****************************************************************************/

static void Chip_USB_PllSetup(void)
{
1a00128c:	b508      	push	{r3, lr}
	/* No need to setup anything if PLL is already setup for the frequency */
	if (Chip_Clock_GetClockInputHz(CLKIN_USBPLL) == usbPLLSetup.freq)
1a00128e:	2007      	movs	r0, #7
1a001290:	f7ff fe46 	bl	1a000f20 <Chip_Clock_GetClockInputHz>
1a001294:	4b08      	ldr	r3, [pc, #32]	; (1a0012b8 <Chip_USB_PllSetup+0x2c>)
1a001296:	4298      	cmp	r0, r3
1a001298:	d00d      	beq.n	1a0012b6 <Chip_USB_PllSetup+0x2a>
		return ;

	/* Setup default USB PLL state for a 480MHz output and attach */
	Chip_Clock_SetupPLL(CLKIN_CRYSTAL, CGU_USB_PLL, &usbPLLSetup);
1a00129a:	2006      	movs	r0, #6
1a00129c:	2100      	movs	r1, #0
1a00129e:	4a07      	ldr	r2, [pc, #28]	; (1a0012bc <Chip_USB_PllSetup+0x30>)
1a0012a0:	f7ff ffc4 	bl	1a00122c <Chip_Clock_SetupPLL>

	/* enable USB PLL */
	Chip_Clock_EnablePLL(CGU_USB_PLL);
1a0012a4:	2000      	movs	r0, #0
1a0012a6:	f7ff ffe1 	bl	1a00126c <Chip_Clock_EnablePLL>

	/* Wait for PLL lock */
	while (!(Chip_Clock_GetPLLStatus(CGU_USB_PLL) & CGU_PLL_LOCKED)) {}
1a0012aa:	2000      	movs	r0, #0
1a0012ac:	f7ff ffe8 	bl	1a001280 <Chip_Clock_GetPLLStatus>
1a0012b0:	f010 0f01 	tst.w	r0, #1
1a0012b4:	d0f9      	beq.n	1a0012aa <Chip_USB_PllSetup+0x1e>
1a0012b6:	bd08      	pop	{r3, pc}
1a0012b8:	1c9c3800 	.word	0x1c9c3800
1a0012bc:	1a001dcc 	.word	0x1a001dcc

1a0012c0 <Chip_USB0_Init>:
/*****************************************************************************
 * Public functions
 ****************************************************************************/

void Chip_USB0_Init(void)
{
1a0012c0:	b508      	push	{r3, lr}
	/* Set up USB PLL */
	Chip_USB_PllSetup();
1a0012c2:	f7ff ffe3 	bl	1a00128c <Chip_USB_PllSetup>

	/* Setup USB0 base clock as clock out from USB PLL */
	Chip_Clock_SetBaseClock( CLK_BASE_USB0, CLKIN_USBPLL, true, true);
1a0012c6:	2001      	movs	r0, #1
1a0012c8:	2107      	movs	r1, #7
1a0012ca:	4602      	mov	r2, r0
1a0012cc:	4603      	mov	r3, r0
1a0012ce:	f7ff ff09 	bl	1a0010e4 <Chip_Clock_SetBaseClock>

	/* enable USB main clock */
	Chip_Clock_EnableBaseClock(CLK_BASE_USB0);
1a0012d2:	2001      	movs	r0, #1
1a0012d4:	f7ff ff28 	bl	1a001128 <Chip_Clock_EnableBaseClock>
	Chip_Clock_EnableOpts(CLK_MX_USB0, true, true, 1);
1a0012d8:	2065      	movs	r0, #101	; 0x65
1a0012da:	2101      	movs	r1, #1
1a0012dc:	460a      	mov	r2, r1
1a0012de:	460b      	mov	r3, r1
1a0012e0:	f7ff ff46 	bl	1a001170 <Chip_Clock_EnableOpts>
 * @note	The USB0 PLL & clock should be configured before calling this function. This function
 * should be called before the USB0 registers are accessed.
 */
STATIC INLINE void Chip_CREG_EnableUSB0Phy(void)
{
	LPC_CREG->CREG0 &= ~(1 << 5);
1a0012e4:	4a02      	ldr	r2, [pc, #8]	; (1a0012f0 <Chip_USB0_Init+0x30>)
1a0012e6:	6853      	ldr	r3, [r2, #4]
1a0012e8:	f023 0320 	bic.w	r3, r3, #32
1a0012ec:	6053      	str	r3, [r2, #4]
1a0012ee:	bd08      	pop	{r3, pc}
1a0012f0:	40043000 	.word	0x40043000

1a0012f4 <SystemCoreClockUpdate>:


/* Update system core clock rate, should be called if the system has
   a clock rate change */
void SystemCoreClockUpdate(void)
{
1a0012f4:	b508      	push	{r3, lr}
	/* CPU core speed */
	SystemCoreClock = Chip_Clock_GetRate(CLK_MX_MXCORE);
1a0012f6:	2069      	movs	r0, #105	; 0x69
1a0012f8:	f7ff ff72 	bl	1a0011e0 <Chip_Clock_GetRate>
1a0012fc:	4b01      	ldr	r3, [pc, #4]	; (1a001304 <SystemCoreClockUpdate+0x10>)
1a0012fe:	6018      	str	r0, [r3, #0]
1a001300:	bd08      	pop	{r3, pc}
1a001302:	bf00      	nop
1a001304:	100000ac 	.word	0x100000ac

1a001308 <Chip_SetupCoreClock>:
/*****************************************************************************
 * Public functions
 ****************************************************************************/
/* Setup Chip Core clock */
void Chip_SetupCoreClock(CHIP_CGU_CLKIN_T clkin, uint32_t core_freq, bool setbase)
{
1a001308:	b570      	push	{r4, r5, r6, lr}
1a00130a:	b08a      	sub	sp, #40	; 0x28
1a00130c:	4605      	mov	r5, r0
1a00130e:	460e      	mov	r6, r1
1a001310:	4614      	mov	r4, r2
	int i;
	volatile uint32_t delay = 10000; // FIXME: original was 500, fix for horrible crystals. @Eric
1a001312:	f242 7310 	movw	r3, #10000	; 0x2710
1a001316:	9309      	str	r3, [sp, #36]	; 0x24
	uint32_t direct = 0, pdivide = 0;
	PLL_PARAM_T ppll;

	if (clkin == CLKIN_CRYSTAL) {
1a001318:	2806      	cmp	r0, #6
1a00131a:	d101      	bne.n	1a001320 <Chip_SetupCoreClock+0x18>
		/* Switch main system clocking to crystal */
		Chip_Clock_EnableCrystal();
1a00131c:	f7ff fdbe 	bl	1a000e9c <Chip_Clock_EnableCrystal>
	}
	Chip_Clock_SetBaseClock(CLK_BASE_MX, clkin, true, false);
1a001320:	2004      	movs	r0, #4
1a001322:	4629      	mov	r1, r5
1a001324:	2201      	movs	r2, #1
1a001326:	2300      	movs	r3, #0
1a001328:	f7ff fedc 	bl	1a0010e4 <Chip_Clock_SetBaseClock>
 * Saves power if the main PLL is not needed.
 */
__STATIC_INLINE void Chip_Clock_DisableMainPLL(void)
{
	/* power down main PLL */
	LPC_CGU->PLL1_CTRL |= 1;
1a00132c:	4a47      	ldr	r2, [pc, #284]	; (1a00144c <Chip_SetupCoreClock+0x144>)
1a00132e:	6c53      	ldr	r3, [r2, #68]	; 0x44
1a001330:	f043 0301 	orr.w	r3, r3, #1
1a001334:	6453      	str	r3, [r2, #68]	; 0x44
	Chip_Clock_DisableMainPLL(); /* Disable PLL */

	/* Calculate the PLL Parameters */
	ppll.srcin = clkin;
1a001336:	f88d 5008 	strb.w	r5, [sp, #8]
	Chip_Clock_CalcMainPLLValue(core_freq, &ppll);
1a00133a:	4630      	mov	r0, r6
1a00133c:	a901      	add	r1, sp, #4
1a00133e:	f7ff fe4b 	bl	1a000fd8 <Chip_Clock_CalcMainPLLValue>

	if (core_freq > 110000000UL) {
1a001342:	4b43      	ldr	r3, [pc, #268]	; (1a001450 <Chip_SetupCoreClock+0x148>)
1a001344:	429e      	cmp	r6, r3
1a001346:	d913      	bls.n	1a001370 <Chip_SetupCoreClock+0x68>
		if (ppll.ctrl & (1 << 6)) {
1a001348:	9b01      	ldr	r3, [sp, #4]
1a00134a:	f013 0f40 	tst.w	r3, #64	; 0x40
1a00134e:	d000      	beq.n	1a001352 <Chip_SetupCoreClock+0x4a>
			while(1);		// to run in integer mode above 110 MHz, you need to use IDIV clock to boot strap CPU to that freq
1a001350:	e7fe      	b.n	1a001350 <Chip_SetupCoreClock+0x48>
		} else if (ppll.ctrl & (1 << 7)){
1a001352:	f013 0f80 	tst.w	r3, #128	; 0x80
1a001356:	d005      	beq.n	1a001364 <Chip_SetupCoreClock+0x5c>
			direct = 1;
			ppll.ctrl &= ~(1 << 7);
1a001358:	f023 0380 	bic.w	r3, r3, #128	; 0x80
1a00135c:	9301      	str	r3, [sp, #4]
/* Setup Chip Core clock */
void Chip_SetupCoreClock(CHIP_CGU_CLKIN_T clkin, uint32_t core_freq, bool setbase)
{
	int i;
	volatile uint32_t delay = 10000; // FIXME: original was 500, fix for horrible crystals. @Eric
	uint32_t direct = 0, pdivide = 0;
1a00135e:	2500      	movs	r5, #0

	if (core_freq > 110000000UL) {
		if (ppll.ctrl & (1 << 6)) {
			while(1);		// to run in integer mode above 110 MHz, you need to use IDIV clock to boot strap CPU to that freq
		} else if (ppll.ctrl & (1 << 7)){
			direct = 1;
1a001360:	2601      	movs	r6, #1
1a001362:	e007      	b.n	1a001374 <Chip_SetupCoreClock+0x6c>
			ppll.ctrl &= ~(1 << 7);
		} else {
			pdivide = 1;
			ppll.psel++;
1a001364:	9b04      	ldr	r3, [sp, #16]
1a001366:	3301      	adds	r3, #1
1a001368:	9304      	str	r3, [sp, #16]
			while(1);		// to run in integer mode above 110 MHz, you need to use IDIV clock to boot strap CPU to that freq
		} else if (ppll.ctrl & (1 << 7)){
			direct = 1;
			ppll.ctrl &= ~(1 << 7);
		} else {
			pdivide = 1;
1a00136a:	2501      	movs	r5, #1
/* Setup Chip Core clock */
void Chip_SetupCoreClock(CHIP_CGU_CLKIN_T clkin, uint32_t core_freq, bool setbase)
{
	int i;
	volatile uint32_t delay = 10000; // FIXME: original was 500, fix for horrible crystals. @Eric
	uint32_t direct = 0, pdivide = 0;
1a00136c:	2600      	movs	r6, #0
1a00136e:	e001      	b.n	1a001374 <Chip_SetupCoreClock+0x6c>
1a001370:	2500      	movs	r5, #0
1a001372:	462e      	mov	r6, r5
 * Make sure the main PLL is enabled.
 */
__STATIC_INLINE void Chip_Clock_SetupMainPLL(const PLL_PARAM_T *ppll)
{
	/* power up main PLL */
    LPC_CGU->PLL1_CTRL = ppll->ctrl | ((uint32_t) ppll->srcin << 24) | (ppll->msel << 16) | (ppll->nsel << 12) | (ppll->psel << 8) | ( 1 << 11);	
1a001374:	f89d 2008 	ldrb.w	r2, [sp, #8]
1a001378:	9b01      	ldr	r3, [sp, #4]
1a00137a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
1a00137e:	9a05      	ldr	r2, [sp, #20]
1a001380:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
1a001384:	9a03      	ldr	r2, [sp, #12]
1a001386:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
1a00138a:	9a04      	ldr	r2, [sp, #16]
1a00138c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
1a001390:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
1a001394:	4a2d      	ldr	r2, [pc, #180]	; (1a00144c <Chip_SetupCoreClock+0x144>)
1a001396:	6453      	str	r3, [r2, #68]	; 0x44
 * @note	The main PLL should be locked prior to using it as a clock input for a base clock.
 */
__STATIC_INLINE int Chip_Clock_MainPLLLocked(void)
{
	/* Return true if locked */
	return (LPC_CGU->PLL1_STAT & 1) != 0;
1a001398:	4b2c      	ldr	r3, [pc, #176]	; (1a00144c <Chip_SetupCoreClock+0x144>)
1a00139a:	6c1b      	ldr	r3, [r3, #64]	; 0x40

	/* Setup and start the PLL */
	Chip_Clock_SetupMainPLL(&ppll);

	/* Wait for the PLL to lock */
	while(!Chip_Clock_MainPLLLocked()) {}
1a00139c:	f013 0f01 	tst.w	r3, #1
1a0013a0:	d0fa      	beq.n	1a001398 <Chip_SetupCoreClock+0x90>

	/* Set core clock base as PLL1 */
	Chip_Clock_SetBaseClock(CLK_BASE_MX, CLKIN_MAINPLL, true, false);
1a0013a2:	2004      	movs	r0, #4
1a0013a4:	2109      	movs	r1, #9
1a0013a6:	2201      	movs	r2, #1
1a0013a8:	2300      	movs	r3, #0
1a0013aa:	f7ff fe9b 	bl	1a0010e4 <Chip_Clock_SetBaseClock>

	if (direct) {
1a0013ae:	b1ee      	cbz	r6, 1a0013ec <Chip_SetupCoreClock+0xe4>
		delay = 10000; // FIXME: original was 1000, fix for horrible crystals. @Eric
1a0013b0:	f242 7310 	movw	r3, #10000	; 0x2710
1a0013b4:	9309      	str	r3, [sp, #36]	; 0x24
		while(delay --){} /* Wait for approx 50 uSec -- for power supply to stabilize*/
1a0013b6:	9b09      	ldr	r3, [sp, #36]	; 0x24
1a0013b8:	1e5a      	subs	r2, r3, #1
1a0013ba:	9209      	str	r2, [sp, #36]	; 0x24
1a0013bc:	2b00      	cmp	r3, #0
1a0013be:	d1fa      	bne.n	1a0013b6 <Chip_SetupCoreClock+0xae>
		ppll.ctrl |= 1 << 7;
1a0013c0:	9b01      	ldr	r3, [sp, #4]
1a0013c2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
1a0013c6:	9301      	str	r3, [sp, #4]
 * Make sure the main PLL is enabled.
 */
__STATIC_INLINE void Chip_Clock_SetupMainPLL(const PLL_PARAM_T *ppll)
{
	/* power up main PLL */
    LPC_CGU->PLL1_CTRL = ppll->ctrl | ((uint32_t) ppll->srcin << 24) | (ppll->msel << 16) | (ppll->nsel << 12) | (ppll->psel << 8) | ( 1 << 11);	
1a0013c8:	f89d 2008 	ldrb.w	r2, [sp, #8]
1a0013cc:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
1a0013d0:	9a05      	ldr	r2, [sp, #20]
1a0013d2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
1a0013d6:	9a03      	ldr	r2, [sp, #12]
1a0013d8:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
1a0013dc:	9a04      	ldr	r2, [sp, #16]
1a0013de:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
1a0013e2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
1a0013e6:	4a19      	ldr	r2, [pc, #100]	; (1a00144c <Chip_SetupCoreClock+0x144>)
1a0013e8:	6453      	str	r3, [r2, #68]	; 0x44
1a0013ea:	e01c      	b.n	1a001426 <Chip_SetupCoreClock+0x11e>
		Chip_Clock_SetupMainPLL(&ppll); /* Set DIRECT to operate at full frequency */
	} else if (pdivide) {
1a0013ec:	b1dd      	cbz	r5, 1a001426 <Chip_SetupCoreClock+0x11e>
		delay = 10000; // FIXME: original was 1000, fix for horrible crystals. @Eric
1a0013ee:	f242 7310 	movw	r3, #10000	; 0x2710
1a0013f2:	9309      	str	r3, [sp, #36]	; 0x24
		while(delay --){} /* Wait for approx 50 uSec -- for power supply to stabilize */
1a0013f4:	9b09      	ldr	r3, [sp, #36]	; 0x24
1a0013f6:	1e5a      	subs	r2, r3, #1
1a0013f8:	9209      	str	r2, [sp, #36]	; 0x24
1a0013fa:	2b00      	cmp	r3, #0
1a0013fc:	d1fa      	bne.n	1a0013f4 <Chip_SetupCoreClock+0xec>
		ppll.psel--;
1a0013fe:	9b04      	ldr	r3, [sp, #16]
1a001400:	1e59      	subs	r1, r3, #1
1a001402:	9104      	str	r1, [sp, #16]
1a001404:	f89d 2008 	ldrb.w	r2, [sp, #8]
1a001408:	9b01      	ldr	r3, [sp, #4]
1a00140a:	ea43 6202 	orr.w	r2, r3, r2, lsl #24
1a00140e:	9b05      	ldr	r3, [sp, #20]
1a001410:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
1a001414:	9b03      	ldr	r3, [sp, #12]
1a001416:	ea42 3303 	orr.w	r3, r2, r3, lsl #12
1a00141a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
1a00141e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
1a001422:	4a0a      	ldr	r2, [pc, #40]	; (1a00144c <Chip_SetupCoreClock+0x144>)
1a001424:	6453      	str	r3, [r2, #68]	; 0x44
		Chip_Clock_SetupMainPLL(&ppll); /* Set PDIV to operate at full frequency */
	}

	if (setbase) {
1a001426:	b964      	cbnz	r4, 1a001442 <Chip_SetupCoreClock+0x13a>
1a001428:	e00e      	b.n	1a001448 <Chip_SetupCoreClock+0x140>
		/* Setup system base clocks and initial states. This won't enable and
		   disable individual clocks, but sets up the base clock sources for
		   each individual peripheral clock. */
		for (i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); i++) {
			Chip_Clock_SetBaseClock(InitClkStates[i].clk, InitClkStates[i].clkin,
1a00142a:	4a0a      	ldr	r2, [pc, #40]	; (1a001454 <Chip_SetupCoreClock+0x14c>)
1a00142c:	eb02 0384 	add.w	r3, r2, r4, lsl #2
1a001430:	f812 0024 	ldrb.w	r0, [r2, r4, lsl #2]
1a001434:	7859      	ldrb	r1, [r3, #1]
1a001436:	789a      	ldrb	r2, [r3, #2]
1a001438:	78db      	ldrb	r3, [r3, #3]
1a00143a:	f7ff fe53 	bl	1a0010e4 <Chip_Clock_SetBaseClock>

	if (setbase) {
		/* Setup system base clocks and initial states. This won't enable and
		   disable individual clocks, but sets up the base clock sources for
		   each individual peripheral clock. */
		for (i = 0; i < (sizeof(InitClkStates) / sizeof(InitClkStates[0])); i++) {
1a00143e:	3401      	adds	r4, #1
1a001440:	e000      	b.n	1a001444 <Chip_SetupCoreClock+0x13c>
1a001442:	2400      	movs	r4, #0
1a001444:	2c11      	cmp	r4, #17
1a001446:	d9f0      	bls.n	1a00142a <Chip_SetupCoreClock+0x122>
			Chip_Clock_SetBaseClock(InitClkStates[i].clk, InitClkStates[i].clkin,
									InitClkStates[i].autoblock_enab, InitClkStates[i].powerdn);
		}
	}
}
1a001448:	b00a      	add	sp, #40	; 0x28
1a00144a:	bd70      	pop	{r4, r5, r6, pc}
1a00144c:	40050000 	.word	0x40050000
1a001450:	068e7780 	.word	0x068e7780
1a001454:	1a001de0 	.word	0x1a001de0

1a001458 <Chip_GPIO_Init>:
 * Public functions
 ****************************************************************************/

/* Initialize GPIO block */
void Chip_GPIO_Init(LPC_GPIO_T *pGPIO)
{
1a001458:	4770      	bx	lr
1a00145a:	bf00      	nop

1a00145c <Chip_SSP_GetClockIndex>:
/* Returns clock index for the register interface */
STATIC CHIP_CCU_CLK_T Chip_SSP_GetClockIndex(LPC_SSP_T *pSSP)
{
	CHIP_CCU_CLK_T clkSSP;

	if (pSSP == LPC_SSP1) {
1a00145c:	4b03      	ldr	r3, [pc, #12]	; (1a00146c <Chip_SSP_GetClockIndex+0x10>)
1a00145e:	4298      	cmp	r0, r3
1a001460:	d101      	bne.n	1a001466 <Chip_SSP_GetClockIndex+0xa>
		clkSSP = CLK_MX_SSP1;
1a001462:	20a5      	movs	r0, #165	; 0xa5
1a001464:	4770      	bx	lr
	}
	else {
		clkSSP = CLK_MX_SSP0;
1a001466:	2083      	movs	r0, #131	; 0x83
	}

	return clkSSP;
}
1a001468:	4770      	bx	lr
1a00146a:	bf00      	nop
1a00146c:	400c5000 	.word	0x400c5000

1a001470 <Chip_SSP_GetPeriphClockIndex>:
/* Returns clock index for the peripheral block */
STATIC CHIP_CCU_CLK_T Chip_SSP_GetPeriphClockIndex(LPC_SSP_T *pSSP)
{
	CHIP_CCU_CLK_T clkSSP;

	if (pSSP == LPC_SSP1) {
1a001470:	4b04      	ldr	r3, [pc, #16]	; (1a001484 <Chip_SSP_GetPeriphClockIndex+0x14>)
1a001472:	4298      	cmp	r0, r3
1a001474:	d102      	bne.n	1a00147c <Chip_SSP_GetPeriphClockIndex+0xc>
		clkSSP = CLK_APB2_SSP1;
1a001476:	f44f 70f1 	mov.w	r0, #482	; 0x1e2
1a00147a:	4770      	bx	lr
	}
	else {
		clkSSP = CLK_APB0_SSP0;
1a00147c:	f240 2002 	movw	r0, #514	; 0x202
	}

	return clkSSP;
}
1a001480:	4770      	bx	lr
1a001482:	bf00      	nop
1a001484:	400c5000 	.word	0x400c5000

1a001488 <Chip_SSP_SetClockRate>:

/*Set up output clocks per bit for SSP bus*/
void Chip_SSP_SetClockRate(LPC_SSP_T *pSSP, uint32_t clk_rate, uint32_t prescale)
{
	uint32_t temp;
	temp = pSSP->CR0 & (~(SSP_CR0_SCR(0xFF)));
1a001488:	6803      	ldr	r3, [r0, #0]
1a00148a:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
	pSSP->CR0 = temp | (SSP_CR0_SCR(clk_rate));
1a00148e:	0209      	lsls	r1, r1, #8
1a001490:	b289      	uxth	r1, r1
1a001492:	430b      	orrs	r3, r1
1a001494:	6003      	str	r3, [r0, #0]
	pSSP->CPSR = prescale;
1a001496:	6102      	str	r2, [r0, #16]
1a001498:	4770      	bx	lr
1a00149a:	bf00      	nop

1a00149c <Chip_SSP_SetBitRate>:
	}
}

/* Set the clock frequency for SSP interface */
void Chip_SSP_SetBitRate(LPC_SSP_T *pSSP, uint32_t bitRate)
{
1a00149c:	b570      	push	{r4, r5, r6, lr}
1a00149e:	4606      	mov	r6, r0
1a0014a0:	460d      	mov	r5, r1
	uint32_t ssp_clk, cr0_div, cmp_clk, prescale;

	ssp_clk = Chip_Clock_GetRate(Chip_SSP_GetPeriphClockIndex(pSSP));
1a0014a2:	f7ff ffe5 	bl	1a001470 <Chip_SSP_GetPeriphClockIndex>
1a0014a6:	f7ff fe9b 	bl	1a0011e0 <Chip_Clock_GetRate>

	cr0_div = 0;
	cmp_clk = 0xFFFFFFFF;
	prescale = 2;
1a0014aa:	2202      	movs	r2, #2
	uint32_t ssp_clk, cr0_div, cmp_clk, prescale;

	ssp_clk = Chip_Clock_GetRate(Chip_SSP_GetPeriphClockIndex(pSSP));

	cr0_div = 0;
	cmp_clk = 0xFFFFFFFF;
1a0014ac:	f04f 33ff 	mov.w	r3, #4294967295
{
	uint32_t ssp_clk, cr0_div, cmp_clk, prescale;

	ssp_clk = Chip_Clock_GetRate(Chip_SSP_GetPeriphClockIndex(pSSP));

	cr0_div = 0;
1a0014b0:	2100      	movs	r1, #0
	cmp_clk = 0xFFFFFFFF;
	prescale = 2;

	while (cmp_clk > bitRate) {
1a0014b2:	e00c      	b.n	1a0014ce <Chip_SSP_SetBitRate+0x32>
		cmp_clk = ssp_clk / ((cr0_div + 1) * prescale);
1a0014b4:	1c4c      	adds	r4, r1, #1
1a0014b6:	fb02 f304 	mul.w	r3, r2, r4
1a0014ba:	fbb0 f3f3 	udiv	r3, r0, r3
		if (cmp_clk > bitRate) {
1a0014be:	42ab      	cmp	r3, r5
1a0014c0:	d905      	bls.n	1a0014ce <Chip_SSP_SetBitRate+0x32>
			cr0_div++;
			if (cr0_div > 0xFF) {
1a0014c2:	2cff      	cmp	r4, #255	; 0xff
1a0014c4:	d902      	bls.n	1a0014cc <Chip_SSP_SetBitRate+0x30>
				cr0_div = 0;
				prescale += 2;
1a0014c6:	3202      	adds	r2, #2
	while (cmp_clk > bitRate) {
		cmp_clk = ssp_clk / ((cr0_div + 1) * prescale);
		if (cmp_clk > bitRate) {
			cr0_div++;
			if (cr0_div > 0xFF) {
				cr0_div = 0;
1a0014c8:	2100      	movs	r1, #0
1a0014ca:	e000      	b.n	1a0014ce <Chip_SSP_SetBitRate+0x32>
	prescale = 2;

	while (cmp_clk > bitRate) {
		cmp_clk = ssp_clk / ((cr0_div + 1) * prescale);
		if (cmp_clk > bitRate) {
			cr0_div++;
1a0014cc:	4621      	mov	r1, r4

	cr0_div = 0;
	cmp_clk = 0xFFFFFFFF;
	prescale = 2;

	while (cmp_clk > bitRate) {
1a0014ce:	42ab      	cmp	r3, r5
1a0014d0:	d8f0      	bhi.n	1a0014b4 <Chip_SSP_SetBitRate+0x18>
				prescale += 2;
			}
		}
	}

	Chip_SSP_SetClockRate(pSSP, cr0_div, prescale);
1a0014d2:	4630      	mov	r0, r6
1a0014d4:	f7ff ffd8 	bl	1a001488 <Chip_SSP_SetClockRate>
1a0014d8:	bd70      	pop	{r4, r5, r6, pc}
1a0014da:	bf00      	nop

1a0014dc <Chip_SSP_Init>:
}

/* Initialize the SSP */
void Chip_SSP_Init(LPC_SSP_T *pSSP)
{
1a0014dc:	b510      	push	{r4, lr}
1a0014de:	4604      	mov	r4, r0
	Chip_Clock_Enable(Chip_SSP_GetClockIndex(pSSP));
1a0014e0:	f7ff ffbc 	bl	1a00145c <Chip_SSP_GetClockIndex>
1a0014e4:	f7ff fe62 	bl	1a0011ac <Chip_Clock_Enable>
	Chip_Clock_Enable(Chip_SSP_GetPeriphClockIndex(pSSP));
1a0014e8:	4620      	mov	r0, r4
1a0014ea:	f7ff ffc1 	bl	1a001470 <Chip_SSP_GetPeriphClockIndex>
1a0014ee:	f7ff fe5d 	bl	1a0011ac <Chip_Clock_Enable>
 *						- SSP_MODE_SLAVE
 * @return	 Nothing
 */
STATIC INLINE void Chip_SSP_Set_Mode(LPC_SSP_T *pSSP, uint32_t mode)
{
	pSSP->CR1 = (pSSP->CR1 & ~(1 << 2)) | mode;
1a0014f2:	6863      	ldr	r3, [r4, #4]
1a0014f4:	f023 0304 	bic.w	r3, r3, #4
1a0014f8:	6063      	str	r3, [r4, #4]
 * @return	 Nothing
 * @note	Note: The clockFormat is only used in SPI mode
 */
STATIC INLINE void Chip_SSP_SetFormat(LPC_SSP_T *pSSP, uint32_t bits, uint32_t frameFormat, uint32_t clockMode)
{
	pSSP->CR0 = (pSSP->CR0 & ~0xFF) | bits | frameFormat | clockMode;
1a0014fa:	6823      	ldr	r3, [r4, #0]
1a0014fc:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
1a001500:	f043 0307 	orr.w	r3, r3, #7
1a001504:	6023      	str	r3, [r4, #0]

	Chip_SSP_Set_Mode(pSSP, SSP_MODE_MASTER);
	Chip_SSP_SetFormat(pSSP, SSP_BITS_8, SSP_FRAMEFORMAT_SPI, SSP_CLOCK_CPHA0_CPOL0);
	Chip_SSP_SetBitRate(pSSP, 100000);
1a001506:	4620      	mov	r0, r4
1a001508:	4901      	ldr	r1, [pc, #4]	; (1a001510 <Chip_SSP_Init+0x34>)
1a00150a:	f7ff ffc7 	bl	1a00149c <Chip_SSP_SetBitRate>
1a00150e:	bd10      	pop	{r4, pc}
1a001510:	000186a0 	.word	0x000186a0

1a001514 <Chip_I2C_EventHandler>:
{
	struct i2c_interface *iic = &i2c[id];
	volatile I2C_STATUS_T *stat;

	/* Only WAIT event needs to be handled */
	if (event != I2C_EVENT_WAIT) {
1a001514:	2901      	cmp	r1, #1
1a001516:	d109      	bne.n	1a00152c <Chip_I2C_EventHandler+0x18>
		return;
	}

	stat = &iic->mXfer->status;
1a001518:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
1a00151c:	0080      	lsls	r0, r0, #2
1a00151e:	4b04      	ldr	r3, [pc, #16]	; (1a001530 <Chip_I2C_EventHandler+0x1c>)
1a001520:	4418      	add	r0, r3
1a001522:	6902      	ldr	r2, [r0, #16]
	/* Wait for the status to change */
	while (*stat == I2C_STATUS_BUSY) {}
1a001524:	7d13      	ldrb	r3, [r2, #20]
1a001526:	b2db      	uxtb	r3, r3
1a001528:	2b04      	cmp	r3, #4
1a00152a:	d0fb      	beq.n	1a001524 <Chip_I2C_EventHandler+0x10>
1a00152c:	4770      	bx	lr
1a00152e:	bf00      	nop
1a001530:	10000048 	.word	0x10000048

1a001534 <Chip_I2C_Init>:
	}
}

/* Initializes the LPC_I2C peripheral with specified parameter */
void Chip_I2C_Init(I2C_ID_T id)
{
1a001534:	b570      	push	{r4, r5, r6, lr}
1a001536:	4605      	mov	r5, r0
 * Private functions
 ****************************************************************************/

STATIC INLINE void enableClk(I2C_ID_T id)
{
	Chip_Clock_Enable(i2c[id].clk);
1a001538:	4e06      	ldr	r6, [pc, #24]	; (1a001554 <Chip_I2C_Init+0x20>)
1a00153a:	00c4      	lsls	r4, r0, #3
1a00153c:	1a23      	subs	r3, r4, r0
1a00153e:	009b      	lsls	r3, r3, #2
1a001540:	4433      	add	r3, r6
1a001542:	8898      	ldrh	r0, [r3, #4]
1a001544:	f7ff fe32 	bl	1a0011ac <Chip_Clock_Enable>
void Chip_I2C_Init(I2C_ID_T id)
{
	enableClk(id);

	/* Set I2C operation to default */
	LPC_I2Cx(id)->CONCLR = (I2C_CON_AA | I2C_CON_SI | I2C_CON_STA | I2C_CON_I2EN);
1a001548:	1b60      	subs	r0, r4, r5
1a00154a:	0080      	lsls	r0, r0, #2
1a00154c:	5833      	ldr	r3, [r6, r0]
1a00154e:	226c      	movs	r2, #108	; 0x6c
1a001550:	619a      	str	r2, [r3, #24]
1a001552:	bd70      	pop	{r4, r5, r6, pc}
1a001554:	10000048 	.word	0x10000048

1a001558 <Chip_I2C_SetClockRate>:
	disableClk(id);
}

/* Set up clock rate for LPC_I2C peripheral */
void Chip_I2C_SetClockRate(I2C_ID_T id, uint32_t clockrate)
{
1a001558:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
1a00155c:	460c      	mov	r4, r1
}

/* Get the ADC Clock Rate */
STATIC INLINE uint32_t getClkRate(I2C_ID_T id)
{
	return Chip_Clock_GetRate(i2c[id].clk);
1a00155e:	4f09      	ldr	r7, [pc, #36]	; (1a001584 <Chip_I2C_SetClockRate+0x2c>)
1a001560:	00c5      	lsls	r5, r0, #3
1a001562:	1a2e      	subs	r6, r5, r0
1a001564:	00b6      	lsls	r6, r6, #2
1a001566:	19bb      	adds	r3, r7, r6
1a001568:	8898      	ldrh	r0, [r3, #4]
1a00156a:	f7ff fe39 	bl	1a0011e0 <Chip_Clock_GetRate>
/* Set up clock rate for LPC_I2C peripheral */
void Chip_I2C_SetClockRate(I2C_ID_T id, uint32_t clockrate)
{
	uint32_t SCLValue;

	SCLValue = (getClkRate(id) / clockrate);
1a00156e:	fbb0 f0f4 	udiv	r0, r0, r4
	LPC_I2Cx(id)->SCLH = (uint32_t) (SCLValue >> 1);
1a001572:	59bb      	ldr	r3, [r7, r6]
1a001574:	0842      	lsrs	r2, r0, #1
1a001576:	611a      	str	r2, [r3, #16]
	LPC_I2Cx(id)->SCLL = (uint32_t) (SCLValue - LPC_I2Cx(id)->SCLH);
1a001578:	59bb      	ldr	r3, [r7, r6]
1a00157a:	691a      	ldr	r2, [r3, #16]
1a00157c:	1a80      	subs	r0, r0, r2
1a00157e:	6158      	str	r0, [r3, #20]
1a001580:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
1a001584:	10000048 	.word	0x10000048

1a001588 <SystemInit>:
 */

#include <board.h>

void SystemInit(void)
{
1a001588:	b508      	push	{r3, lr}
   extern void *g_pfnVectors;
   SCB->VTOR = (unsigned int) &g_pfnVectors;
1a00158a:	4b0d      	ldr	r3, [pc, #52]	; (1a0015c0 <SystemInit+0x38>)
1a00158c:	4a0d      	ldr	r2, [pc, #52]	; (1a0015c4 <SystemInit+0x3c>)
1a00158e:	609a      	str	r2, [r3, #8]
 */
__STATIC_INLINE uint32_t SCB_GetFPUType(void)
{
  uint32_t mvfr0;

  mvfr0 = FPU->MVFR0;
1a001590:	f503 730c 	add.w	r3, r3, #560	; 0x230
1a001594:	691b      	ldr	r3, [r3, #16]
  if      ((mvfr0 & (FPU_MVFR0_Single_precision_Msk | FPU_MVFR0_Double_precision_Msk)) == 0x020U)
1a001596:	f403 637f 	and.w	r3, r3, #4080	; 0xff0
1a00159a:	2b20      	cmp	r3, #32
1a00159c:	d101      	bne.n	1a0015a2 <SystemInit+0x1a>
  {
    return 1U;           /* Single precision FPU */
1a00159e:	2301      	movs	r3, #1
1a0015a0:	e000      	b.n	1a0015a4 <SystemInit+0x1c>
  }
  else
  {
    return 0U;           /* No FPU */
1a0015a2:	2300      	movs	r3, #0

   if (SCB_GetFPUType() > 0)
1a0015a4:	b133      	cbz	r3, 1a0015b4 <SystemInit+0x2c>
      SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
1a0015a6:	4a06      	ldr	r2, [pc, #24]	; (1a0015c0 <SystemInit+0x38>)
1a0015a8:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
1a0015ac:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
1a0015b0:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

   /* Board specific SystemInit */
   Board_SystemInit();
1a0015b4:	f7ff fa5e 	bl	1a000a74 <Board_SystemInit>
   Board_Init();
1a0015b8:	f7ff f9f2 	bl	1a0009a0 <Board_Init>
1a0015bc:	bd08      	pop	{r3, pc}
1a0015be:	bf00      	nop
1a0015c0:	e000ed00 	.word	0xe000ed00
1a0015c4:	1a000000 	.word	0x1a000000

1a0015c8 <__aeabi_uldivmod>:
1a0015c8:	b953      	cbnz	r3, 1a0015e0 <__aeabi_uldivmod+0x18>
1a0015ca:	b94a      	cbnz	r2, 1a0015e0 <__aeabi_uldivmod+0x18>
1a0015cc:	2900      	cmp	r1, #0
1a0015ce:	bf08      	it	eq
1a0015d0:	2800      	cmpeq	r0, #0
1a0015d2:	bf1c      	itt	ne
1a0015d4:	f04f 31ff 	movne.w	r1, #4294967295
1a0015d8:	f04f 30ff 	movne.w	r0, #4294967295
1a0015dc:	f000 b83c 	b.w	1a001658 <__aeabi_idiv0>
1a0015e0:	b082      	sub	sp, #8
1a0015e2:	46ec      	mov	ip, sp
1a0015e4:	e92d 5000 	stmdb	sp!, {ip, lr}
1a0015e8:	f000 f81e 	bl	1a001628 <__gnu_uldivmod_helper>
1a0015ec:	f8dd e004 	ldr.w	lr, [sp, #4]
1a0015f0:	b002      	add	sp, #8
1a0015f2:	bc0c      	pop	{r2, r3}
1a0015f4:	4770      	bx	lr
1a0015f6:	bf00      	nop

1a0015f8 <__gnu_ldivmod_helper>:
1a0015f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
1a0015fc:	9c06      	ldr	r4, [sp, #24]
1a0015fe:	4615      	mov	r5, r2
1a001600:	4606      	mov	r6, r0
1a001602:	460f      	mov	r7, r1
1a001604:	4698      	mov	r8, r3
1a001606:	f000 f829 	bl	1a00165c <__divdi3>
1a00160a:	fb05 f301 	mul.w	r3, r5, r1
1a00160e:	fb00 3808 	mla	r8, r0, r8, r3
1a001612:	fba5 2300 	umull	r2, r3, r5, r0
1a001616:	1ab2      	subs	r2, r6, r2
1a001618:	4443      	add	r3, r8
1a00161a:	eb67 0303 	sbc.w	r3, r7, r3
1a00161e:	e9c4 2300 	strd	r2, r3, [r4]
1a001622:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
1a001626:	bf00      	nop

1a001628 <__gnu_uldivmod_helper>:
1a001628:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
1a00162c:	9c06      	ldr	r4, [sp, #24]
1a00162e:	4690      	mov	r8, r2
1a001630:	4606      	mov	r6, r0
1a001632:	460f      	mov	r7, r1
1a001634:	461d      	mov	r5, r3
1a001636:	f000 f95f 	bl	1a0018f8 <__udivdi3>
1a00163a:	fb00 f505 	mul.w	r5, r0, r5
1a00163e:	fba0 2308 	umull	r2, r3, r0, r8
1a001642:	fb08 5501 	mla	r5, r8, r1, r5
1a001646:	1ab2      	subs	r2, r6, r2
1a001648:	442b      	add	r3, r5
1a00164a:	eb67 0303 	sbc.w	r3, r7, r3
1a00164e:	e9c4 2300 	strd	r2, r3, [r4]
1a001652:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
1a001656:	bf00      	nop

1a001658 <__aeabi_idiv0>:
1a001658:	4770      	bx	lr
1a00165a:	bf00      	nop

1a00165c <__divdi3>:
1a00165c:	2900      	cmp	r1, #0
1a00165e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
1a001662:	f2c0 80a6 	blt.w	1a0017b2 <__divdi3+0x156>
1a001666:	2600      	movs	r6, #0
1a001668:	2b00      	cmp	r3, #0
1a00166a:	f2c0 809c 	blt.w	1a0017a6 <__divdi3+0x14a>
1a00166e:	4688      	mov	r8, r1
1a001670:	4694      	mov	ip, r2
1a001672:	469e      	mov	lr, r3
1a001674:	4615      	mov	r5, r2
1a001676:	4604      	mov	r4, r0
1a001678:	460f      	mov	r7, r1
1a00167a:	2b00      	cmp	r3, #0
1a00167c:	d13d      	bne.n	1a0016fa <__divdi3+0x9e>
1a00167e:	428a      	cmp	r2, r1
1a001680:	d959      	bls.n	1a001736 <__divdi3+0xda>
1a001682:	fab2 f382 	clz	r3, r2
1a001686:	b13b      	cbz	r3, 1a001698 <__divdi3+0x3c>
1a001688:	f1c3 0220 	rsb	r2, r3, #32
1a00168c:	409f      	lsls	r7, r3
1a00168e:	fa20 f202 	lsr.w	r2, r0, r2
1a001692:	409d      	lsls	r5, r3
1a001694:	4317      	orrs	r7, r2
1a001696:	409c      	lsls	r4, r3
1a001698:	0c29      	lsrs	r1, r5, #16
1a00169a:	0c22      	lsrs	r2, r4, #16
1a00169c:	fbb7 fef1 	udiv	lr, r7, r1
1a0016a0:	b2a8      	uxth	r0, r5
1a0016a2:	fb01 771e 	mls	r7, r1, lr, r7
1a0016a6:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
1a0016aa:	fb00 f30e 	mul.w	r3, r0, lr
1a0016ae:	42bb      	cmp	r3, r7
1a0016b0:	d90a      	bls.n	1a0016c8 <__divdi3+0x6c>
1a0016b2:	197f      	adds	r7, r7, r5
1a0016b4:	f10e 32ff 	add.w	r2, lr, #4294967295
1a0016b8:	f080 8105 	bcs.w	1a0018c6 <__divdi3+0x26a>
1a0016bc:	42bb      	cmp	r3, r7
1a0016be:	f240 8102 	bls.w	1a0018c6 <__divdi3+0x26a>
1a0016c2:	f1ae 0e02 	sub.w	lr, lr, #2
1a0016c6:	442f      	add	r7, r5
1a0016c8:	1aff      	subs	r7, r7, r3
1a0016ca:	b2a4      	uxth	r4, r4
1a0016cc:	fbb7 f3f1 	udiv	r3, r7, r1
1a0016d0:	fb01 7713 	mls	r7, r1, r3, r7
1a0016d4:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
1a0016d8:	fb00 f003 	mul.w	r0, r0, r3
1a0016dc:	42b8      	cmp	r0, r7
1a0016de:	d908      	bls.n	1a0016f2 <__divdi3+0x96>
1a0016e0:	197f      	adds	r7, r7, r5
1a0016e2:	f103 32ff 	add.w	r2, r3, #4294967295
1a0016e6:	f080 80f0 	bcs.w	1a0018ca <__divdi3+0x26e>
1a0016ea:	42b8      	cmp	r0, r7
1a0016ec:	f240 80ed 	bls.w	1a0018ca <__divdi3+0x26e>
1a0016f0:	3b02      	subs	r3, #2
1a0016f2:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
1a0016f6:	2200      	movs	r2, #0
1a0016f8:	e003      	b.n	1a001702 <__divdi3+0xa6>
1a0016fa:	428b      	cmp	r3, r1
1a0016fc:	d90f      	bls.n	1a00171e <__divdi3+0xc2>
1a0016fe:	2200      	movs	r2, #0
1a001700:	4613      	mov	r3, r2
1a001702:	1c34      	adds	r4, r6, #0
1a001704:	bf18      	it	ne
1a001706:	2401      	movne	r4, #1
1a001708:	4260      	negs	r0, r4
1a00170a:	f04f 0500 	mov.w	r5, #0
1a00170e:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
1a001712:	4058      	eors	r0, r3
1a001714:	4051      	eors	r1, r2
1a001716:	1900      	adds	r0, r0, r4
1a001718:	4169      	adcs	r1, r5
1a00171a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
1a00171e:	fab3 f283 	clz	r2, r3
1a001722:	2a00      	cmp	r2, #0
1a001724:	f040 8086 	bne.w	1a001834 <__divdi3+0x1d8>
1a001728:	428b      	cmp	r3, r1
1a00172a:	d302      	bcc.n	1a001732 <__divdi3+0xd6>
1a00172c:	4584      	cmp	ip, r0
1a00172e:	f200 80db 	bhi.w	1a0018e8 <__divdi3+0x28c>
1a001732:	2301      	movs	r3, #1
1a001734:	e7e5      	b.n	1a001702 <__divdi3+0xa6>
1a001736:	b912      	cbnz	r2, 1a00173e <__divdi3+0xe2>
1a001738:	2301      	movs	r3, #1
1a00173a:	fbb3 f5f2 	udiv	r5, r3, r2
1a00173e:	fab5 f085 	clz	r0, r5
1a001742:	2800      	cmp	r0, #0
1a001744:	d13b      	bne.n	1a0017be <__divdi3+0x162>
1a001746:	1b78      	subs	r0, r7, r5
1a001748:	ea4f 4e15 	mov.w	lr, r5, lsr #16
1a00174c:	fa1f fc85 	uxth.w	ip, r5
1a001750:	2201      	movs	r2, #1
1a001752:	fbb0 f8fe 	udiv	r8, r0, lr
1a001756:	0c21      	lsrs	r1, r4, #16
1a001758:	fb0e 0718 	mls	r7, lr, r8, r0
1a00175c:	ea41 4707 	orr.w	r7, r1, r7, lsl #16
1a001760:	fb0c f308 	mul.w	r3, ip, r8
1a001764:	42bb      	cmp	r3, r7
1a001766:	d907      	bls.n	1a001778 <__divdi3+0x11c>
1a001768:	197f      	adds	r7, r7, r5
1a00176a:	f108 31ff 	add.w	r1, r8, #4294967295
1a00176e:	d202      	bcs.n	1a001776 <__divdi3+0x11a>
1a001770:	42bb      	cmp	r3, r7
1a001772:	f200 80bd 	bhi.w	1a0018f0 <__divdi3+0x294>
1a001776:	4688      	mov	r8, r1
1a001778:	1aff      	subs	r7, r7, r3
1a00177a:	b2a4      	uxth	r4, r4
1a00177c:	fbb7 f3fe 	udiv	r3, r7, lr
1a001780:	fb0e 7713 	mls	r7, lr, r3, r7
1a001784:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
1a001788:	fb0c fc03 	mul.w	ip, ip, r3
1a00178c:	45bc      	cmp	ip, r7
1a00178e:	d907      	bls.n	1a0017a0 <__divdi3+0x144>
1a001790:	197f      	adds	r7, r7, r5
1a001792:	f103 31ff 	add.w	r1, r3, #4294967295
1a001796:	d202      	bcs.n	1a00179e <__divdi3+0x142>
1a001798:	45bc      	cmp	ip, r7
1a00179a:	f200 80a7 	bhi.w	1a0018ec <__divdi3+0x290>
1a00179e:	460b      	mov	r3, r1
1a0017a0:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
1a0017a4:	e7ad      	b.n	1a001702 <__divdi3+0xa6>
1a0017a6:	4252      	negs	r2, r2
1a0017a8:	ea6f 0606 	mvn.w	r6, r6
1a0017ac:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
1a0017b0:	e75d      	b.n	1a00166e <__divdi3+0x12>
1a0017b2:	4240      	negs	r0, r0
1a0017b4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
1a0017b8:	f04f 36ff 	mov.w	r6, #4294967295
1a0017bc:	e754      	b.n	1a001668 <__divdi3+0xc>
1a0017be:	f1c0 0220 	rsb	r2, r0, #32
1a0017c2:	fa24 f102 	lsr.w	r1, r4, r2
1a0017c6:	fa07 f300 	lsl.w	r3, r7, r0
1a0017ca:	4085      	lsls	r5, r0
1a0017cc:	ea4f 4e15 	mov.w	lr, r5, lsr #16
1a0017d0:	40d7      	lsrs	r7, r2
1a0017d2:	4319      	orrs	r1, r3
1a0017d4:	fbb7 f2fe 	udiv	r2, r7, lr
1a0017d8:	0c0b      	lsrs	r3, r1, #16
1a0017da:	fb0e 7712 	mls	r7, lr, r2, r7
1a0017de:	fa1f fc85 	uxth.w	ip, r5
1a0017e2:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
1a0017e6:	fb0c f702 	mul.w	r7, ip, r2
1a0017ea:	429f      	cmp	r7, r3
1a0017ec:	fa04 f400 	lsl.w	r4, r4, r0
1a0017f0:	d907      	bls.n	1a001802 <__divdi3+0x1a6>
1a0017f2:	195b      	adds	r3, r3, r5
1a0017f4:	f102 30ff 	add.w	r0, r2, #4294967295
1a0017f8:	d274      	bcs.n	1a0018e4 <__divdi3+0x288>
1a0017fa:	429f      	cmp	r7, r3
1a0017fc:	d972      	bls.n	1a0018e4 <__divdi3+0x288>
1a0017fe:	3a02      	subs	r2, #2
1a001800:	442b      	add	r3, r5
1a001802:	1bdf      	subs	r7, r3, r7
1a001804:	b289      	uxth	r1, r1
1a001806:	fbb7 f8fe 	udiv	r8, r7, lr
1a00180a:	fb0e 7318 	mls	r3, lr, r8, r7
1a00180e:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
1a001812:	fb0c f708 	mul.w	r7, ip, r8
1a001816:	429f      	cmp	r7, r3
1a001818:	d908      	bls.n	1a00182c <__divdi3+0x1d0>
1a00181a:	195b      	adds	r3, r3, r5
1a00181c:	f108 31ff 	add.w	r1, r8, #4294967295
1a001820:	d25c      	bcs.n	1a0018dc <__divdi3+0x280>
1a001822:	429f      	cmp	r7, r3
1a001824:	d95a      	bls.n	1a0018dc <__divdi3+0x280>
1a001826:	f1a8 0802 	sub.w	r8, r8, #2
1a00182a:	442b      	add	r3, r5
1a00182c:	1bd8      	subs	r0, r3, r7
1a00182e:	ea48 4202 	orr.w	r2, r8, r2, lsl #16
1a001832:	e78e      	b.n	1a001752 <__divdi3+0xf6>
1a001834:	f1c2 0320 	rsb	r3, r2, #32
1a001838:	fa2c f103 	lsr.w	r1, ip, r3
1a00183c:	fa0e fe02 	lsl.w	lr, lr, r2
1a001840:	fa20 f703 	lsr.w	r7, r0, r3
1a001844:	ea41 0e0e 	orr.w	lr, r1, lr
1a001848:	fa08 f002 	lsl.w	r0, r8, r2
1a00184c:	fa28 f103 	lsr.w	r1, r8, r3
1a001850:	ea4f 451e 	mov.w	r5, lr, lsr #16
1a001854:	4338      	orrs	r0, r7
1a001856:	fbb1 f8f5 	udiv	r8, r1, r5
1a00185a:	0c03      	lsrs	r3, r0, #16
1a00185c:	fb05 1118 	mls	r1, r5, r8, r1
1a001860:	fa1f f78e 	uxth.w	r7, lr
1a001864:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
1a001868:	fb07 f308 	mul.w	r3, r7, r8
1a00186c:	428b      	cmp	r3, r1
1a00186e:	fa0c fc02 	lsl.w	ip, ip, r2
1a001872:	d909      	bls.n	1a001888 <__divdi3+0x22c>
1a001874:	eb11 010e 	adds.w	r1, r1, lr
1a001878:	f108 39ff 	add.w	r9, r8, #4294967295
1a00187c:	d230      	bcs.n	1a0018e0 <__divdi3+0x284>
1a00187e:	428b      	cmp	r3, r1
1a001880:	d92e      	bls.n	1a0018e0 <__divdi3+0x284>
1a001882:	f1a8 0802 	sub.w	r8, r8, #2
1a001886:	4471      	add	r1, lr
1a001888:	1ac9      	subs	r1, r1, r3
1a00188a:	b280      	uxth	r0, r0
1a00188c:	fbb1 f3f5 	udiv	r3, r1, r5
1a001890:	fb05 1113 	mls	r1, r5, r3, r1
1a001894:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
1a001898:	fb07 f703 	mul.w	r7, r7, r3
1a00189c:	428f      	cmp	r7, r1
1a00189e:	d908      	bls.n	1a0018b2 <__divdi3+0x256>
1a0018a0:	eb11 010e 	adds.w	r1, r1, lr
1a0018a4:	f103 30ff 	add.w	r0, r3, #4294967295
1a0018a8:	d216      	bcs.n	1a0018d8 <__divdi3+0x27c>
1a0018aa:	428f      	cmp	r7, r1
1a0018ac:	d914      	bls.n	1a0018d8 <__divdi3+0x27c>
1a0018ae:	3b02      	subs	r3, #2
1a0018b0:	4471      	add	r1, lr
1a0018b2:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
1a0018b6:	1bc9      	subs	r1, r1, r7
1a0018b8:	fba3 890c 	umull	r8, r9, r3, ip
1a0018bc:	4549      	cmp	r1, r9
1a0018be:	d309      	bcc.n	1a0018d4 <__divdi3+0x278>
1a0018c0:	d005      	beq.n	1a0018ce <__divdi3+0x272>
1a0018c2:	2200      	movs	r2, #0
1a0018c4:	e71d      	b.n	1a001702 <__divdi3+0xa6>
1a0018c6:	4696      	mov	lr, r2
1a0018c8:	e6fe      	b.n	1a0016c8 <__divdi3+0x6c>
1a0018ca:	4613      	mov	r3, r2
1a0018cc:	e711      	b.n	1a0016f2 <__divdi3+0x96>
1a0018ce:	4094      	lsls	r4, r2
1a0018d0:	4544      	cmp	r4, r8
1a0018d2:	d2f6      	bcs.n	1a0018c2 <__divdi3+0x266>
1a0018d4:	3b01      	subs	r3, #1
1a0018d6:	e7f4      	b.n	1a0018c2 <__divdi3+0x266>
1a0018d8:	4603      	mov	r3, r0
1a0018da:	e7ea      	b.n	1a0018b2 <__divdi3+0x256>
1a0018dc:	4688      	mov	r8, r1
1a0018de:	e7a5      	b.n	1a00182c <__divdi3+0x1d0>
1a0018e0:	46c8      	mov	r8, r9
1a0018e2:	e7d1      	b.n	1a001888 <__divdi3+0x22c>
1a0018e4:	4602      	mov	r2, r0
1a0018e6:	e78c      	b.n	1a001802 <__divdi3+0x1a6>
1a0018e8:	4613      	mov	r3, r2
1a0018ea:	e70a      	b.n	1a001702 <__divdi3+0xa6>
1a0018ec:	3b02      	subs	r3, #2
1a0018ee:	e757      	b.n	1a0017a0 <__divdi3+0x144>
1a0018f0:	f1a8 0802 	sub.w	r8, r8, #2
1a0018f4:	442f      	add	r7, r5
1a0018f6:	e73f      	b.n	1a001778 <__divdi3+0x11c>

1a0018f8 <__udivdi3>:
1a0018f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
1a0018fc:	2b00      	cmp	r3, #0
1a0018fe:	d144      	bne.n	1a00198a <__udivdi3+0x92>
1a001900:	428a      	cmp	r2, r1
1a001902:	4615      	mov	r5, r2
1a001904:	4604      	mov	r4, r0
1a001906:	d94f      	bls.n	1a0019a8 <__udivdi3+0xb0>
1a001908:	fab2 f782 	clz	r7, r2
1a00190c:	460e      	mov	r6, r1
1a00190e:	b14f      	cbz	r7, 1a001924 <__udivdi3+0x2c>
1a001910:	f1c7 0320 	rsb	r3, r7, #32
1a001914:	40b9      	lsls	r1, r7
1a001916:	fa20 f603 	lsr.w	r6, r0, r3
1a00191a:	fa02 f507 	lsl.w	r5, r2, r7
1a00191e:	430e      	orrs	r6, r1
1a001920:	fa00 f407 	lsl.w	r4, r0, r7
1a001924:	ea4f 4e15 	mov.w	lr, r5, lsr #16
1a001928:	0c23      	lsrs	r3, r4, #16
1a00192a:	fbb6 f0fe 	udiv	r0, r6, lr
1a00192e:	b2af      	uxth	r7, r5
1a001930:	fb0e 6110 	mls	r1, lr, r0, r6
1a001934:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
1a001938:	fb07 f100 	mul.w	r1, r7, r0
1a00193c:	4299      	cmp	r1, r3
1a00193e:	d909      	bls.n	1a001954 <__udivdi3+0x5c>
1a001940:	195b      	adds	r3, r3, r5
1a001942:	f100 32ff 	add.w	r2, r0, #4294967295
1a001946:	f080 80ec 	bcs.w	1a001b22 <__udivdi3+0x22a>
1a00194a:	4299      	cmp	r1, r3
1a00194c:	f240 80e9 	bls.w	1a001b22 <__udivdi3+0x22a>
1a001950:	3802      	subs	r0, #2
1a001952:	442b      	add	r3, r5
1a001954:	1a5a      	subs	r2, r3, r1
1a001956:	b2a4      	uxth	r4, r4
1a001958:	fbb2 f3fe 	udiv	r3, r2, lr
1a00195c:	fb0e 2213 	mls	r2, lr, r3, r2
1a001960:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
1a001964:	fb07 f703 	mul.w	r7, r7, r3
1a001968:	4297      	cmp	r7, r2
1a00196a:	d908      	bls.n	1a00197e <__udivdi3+0x86>
1a00196c:	1952      	adds	r2, r2, r5
1a00196e:	f103 31ff 	add.w	r1, r3, #4294967295
1a001972:	f080 80d8 	bcs.w	1a001b26 <__udivdi3+0x22e>
1a001976:	4297      	cmp	r7, r2
1a001978:	f240 80d5 	bls.w	1a001b26 <__udivdi3+0x22e>
1a00197c:	3b02      	subs	r3, #2
1a00197e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
1a001982:	2600      	movs	r6, #0
1a001984:	4631      	mov	r1, r6
1a001986:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
1a00198a:	428b      	cmp	r3, r1
1a00198c:	d847      	bhi.n	1a001a1e <__udivdi3+0x126>
1a00198e:	fab3 f683 	clz	r6, r3
1a001992:	2e00      	cmp	r6, #0
1a001994:	d148      	bne.n	1a001a28 <__udivdi3+0x130>
1a001996:	428b      	cmp	r3, r1
1a001998:	d302      	bcc.n	1a0019a0 <__udivdi3+0xa8>
1a00199a:	4282      	cmp	r2, r0
1a00199c:	f200 80cd 	bhi.w	1a001b3a <__udivdi3+0x242>
1a0019a0:	2001      	movs	r0, #1
1a0019a2:	4631      	mov	r1, r6
1a0019a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
1a0019a8:	b912      	cbnz	r2, 1a0019b0 <__udivdi3+0xb8>
1a0019aa:	2501      	movs	r5, #1
1a0019ac:	fbb5 f5f2 	udiv	r5, r5, r2
1a0019b0:	fab5 f885 	clz	r8, r5
1a0019b4:	f1b8 0f00 	cmp.w	r8, #0
1a0019b8:	d177      	bne.n	1a001aaa <__udivdi3+0x1b2>
1a0019ba:	1b4a      	subs	r2, r1, r5
1a0019bc:	ea4f 4e15 	mov.w	lr, r5, lsr #16
1a0019c0:	b2af      	uxth	r7, r5
1a0019c2:	2601      	movs	r6, #1
1a0019c4:	fbb2 f0fe 	udiv	r0, r2, lr
1a0019c8:	0c23      	lsrs	r3, r4, #16
1a0019ca:	fb0e 2110 	mls	r1, lr, r0, r2
1a0019ce:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
1a0019d2:	fb07 f300 	mul.w	r3, r7, r0
1a0019d6:	428b      	cmp	r3, r1
1a0019d8:	d907      	bls.n	1a0019ea <__udivdi3+0xf2>
1a0019da:	1949      	adds	r1, r1, r5
1a0019dc:	f100 32ff 	add.w	r2, r0, #4294967295
1a0019e0:	d202      	bcs.n	1a0019e8 <__udivdi3+0xf0>
1a0019e2:	428b      	cmp	r3, r1
1a0019e4:	f200 80ba 	bhi.w	1a001b5c <__udivdi3+0x264>
1a0019e8:	4610      	mov	r0, r2
1a0019ea:	1ac9      	subs	r1, r1, r3
1a0019ec:	b2a4      	uxth	r4, r4
1a0019ee:	fbb1 f3fe 	udiv	r3, r1, lr
1a0019f2:	fb0e 1113 	mls	r1, lr, r3, r1
1a0019f6:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
1a0019fa:	fb07 f703 	mul.w	r7, r7, r3
1a0019fe:	42a7      	cmp	r7, r4
1a001a00:	d908      	bls.n	1a001a14 <__udivdi3+0x11c>
1a001a02:	1964      	adds	r4, r4, r5
1a001a04:	f103 32ff 	add.w	r2, r3, #4294967295
1a001a08:	f080 808f 	bcs.w	1a001b2a <__udivdi3+0x232>
1a001a0c:	42a7      	cmp	r7, r4
1a001a0e:	f240 808c 	bls.w	1a001b2a <__udivdi3+0x232>
1a001a12:	3b02      	subs	r3, #2
1a001a14:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
1a001a18:	4631      	mov	r1, r6
1a001a1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
1a001a1e:	2600      	movs	r6, #0
1a001a20:	4630      	mov	r0, r6
1a001a22:	4631      	mov	r1, r6
1a001a24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
1a001a28:	f1c6 0420 	rsb	r4, r6, #32
1a001a2c:	fa22 f504 	lsr.w	r5, r2, r4
1a001a30:	40b3      	lsls	r3, r6
1a001a32:	432b      	orrs	r3, r5
1a001a34:	fa20 fc04 	lsr.w	ip, r0, r4
1a001a38:	fa01 f706 	lsl.w	r7, r1, r6
1a001a3c:	fa21 f504 	lsr.w	r5, r1, r4
1a001a40:	ea4f 4e13 	mov.w	lr, r3, lsr #16
1a001a44:	ea4c 0707 	orr.w	r7, ip, r7
1a001a48:	fbb5 f8fe 	udiv	r8, r5, lr
1a001a4c:	0c39      	lsrs	r1, r7, #16
1a001a4e:	fb0e 5518 	mls	r5, lr, r8, r5
1a001a52:	fa1f fc83 	uxth.w	ip, r3
1a001a56:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
1a001a5a:	fb0c f108 	mul.w	r1, ip, r8
1a001a5e:	42a9      	cmp	r1, r5
1a001a60:	fa02 f206 	lsl.w	r2, r2, r6
1a001a64:	d904      	bls.n	1a001a70 <__udivdi3+0x178>
1a001a66:	18ed      	adds	r5, r5, r3
1a001a68:	f108 34ff 	add.w	r4, r8, #4294967295
1a001a6c:	d367      	bcc.n	1a001b3e <__udivdi3+0x246>
1a001a6e:	46a0      	mov	r8, r4
1a001a70:	1a6d      	subs	r5, r5, r1
1a001a72:	b2bf      	uxth	r7, r7
1a001a74:	fbb5 f4fe 	udiv	r4, r5, lr
1a001a78:	fb0e 5514 	mls	r5, lr, r4, r5
1a001a7c:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
1a001a80:	fb0c fc04 	mul.w	ip, ip, r4
1a001a84:	458c      	cmp	ip, r1
1a001a86:	d904      	bls.n	1a001a92 <__udivdi3+0x19a>
1a001a88:	18c9      	adds	r1, r1, r3
1a001a8a:	f104 35ff 	add.w	r5, r4, #4294967295
1a001a8e:	d35c      	bcc.n	1a001b4a <__udivdi3+0x252>
1a001a90:	462c      	mov	r4, r5
1a001a92:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
1a001a96:	ebcc 0101 	rsb	r1, ip, r1
1a001a9a:	fba4 2302 	umull	r2, r3, r4, r2
1a001a9e:	4299      	cmp	r1, r3
1a001aa0:	d348      	bcc.n	1a001b34 <__udivdi3+0x23c>
1a001aa2:	d044      	beq.n	1a001b2e <__udivdi3+0x236>
1a001aa4:	4620      	mov	r0, r4
1a001aa6:	2600      	movs	r6, #0
1a001aa8:	e76c      	b.n	1a001984 <__udivdi3+0x8c>
1a001aaa:	f1c8 0420 	rsb	r4, r8, #32
1a001aae:	fa01 f308 	lsl.w	r3, r1, r8
1a001ab2:	fa05 f508 	lsl.w	r5, r5, r8
1a001ab6:	fa20 f704 	lsr.w	r7, r0, r4
1a001aba:	40e1      	lsrs	r1, r4
1a001abc:	ea4f 4e15 	mov.w	lr, r5, lsr #16
1a001ac0:	431f      	orrs	r7, r3
1a001ac2:	fbb1 f6fe 	udiv	r6, r1, lr
1a001ac6:	0c3a      	lsrs	r2, r7, #16
1a001ac8:	fb0e 1116 	mls	r1, lr, r6, r1
1a001acc:	fa1f fc85 	uxth.w	ip, r5
1a001ad0:	ea42 4301 	orr.w	r3, r2, r1, lsl #16
1a001ad4:	fb0c f206 	mul.w	r2, ip, r6
1a001ad8:	429a      	cmp	r2, r3
1a001ada:	fa00 f408 	lsl.w	r4, r0, r8
1a001ade:	d907      	bls.n	1a001af0 <__udivdi3+0x1f8>
1a001ae0:	195b      	adds	r3, r3, r5
1a001ae2:	f106 31ff 	add.w	r1, r6, #4294967295
1a001ae6:	d237      	bcs.n	1a001b58 <__udivdi3+0x260>
1a001ae8:	429a      	cmp	r2, r3
1a001aea:	d935      	bls.n	1a001b58 <__udivdi3+0x260>
1a001aec:	3e02      	subs	r6, #2
1a001aee:	442b      	add	r3, r5
1a001af0:	1a9b      	subs	r3, r3, r2
1a001af2:	b2bf      	uxth	r7, r7
1a001af4:	fbb3 f0fe 	udiv	r0, r3, lr
1a001af8:	fb0e 3310 	mls	r3, lr, r0, r3
1a001afc:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
1a001b00:	fb0c f100 	mul.w	r1, ip, r0
1a001b04:	4299      	cmp	r1, r3
1a001b06:	d907      	bls.n	1a001b18 <__udivdi3+0x220>
1a001b08:	195b      	adds	r3, r3, r5
1a001b0a:	f100 32ff 	add.w	r2, r0, #4294967295
1a001b0e:	d221      	bcs.n	1a001b54 <__udivdi3+0x25c>
1a001b10:	4299      	cmp	r1, r3
1a001b12:	d91f      	bls.n	1a001b54 <__udivdi3+0x25c>
1a001b14:	3802      	subs	r0, #2
1a001b16:	442b      	add	r3, r5
1a001b18:	1a5a      	subs	r2, r3, r1
1a001b1a:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
1a001b1e:	4667      	mov	r7, ip
1a001b20:	e750      	b.n	1a0019c4 <__udivdi3+0xcc>
1a001b22:	4610      	mov	r0, r2
1a001b24:	e716      	b.n	1a001954 <__udivdi3+0x5c>
1a001b26:	460b      	mov	r3, r1
1a001b28:	e729      	b.n	1a00197e <__udivdi3+0x86>
1a001b2a:	4613      	mov	r3, r2
1a001b2c:	e772      	b.n	1a001a14 <__udivdi3+0x11c>
1a001b2e:	40b0      	lsls	r0, r6
1a001b30:	4290      	cmp	r0, r2
1a001b32:	d2b7      	bcs.n	1a001aa4 <__udivdi3+0x1ac>
1a001b34:	1e60      	subs	r0, r4, #1
1a001b36:	2600      	movs	r6, #0
1a001b38:	e724      	b.n	1a001984 <__udivdi3+0x8c>
1a001b3a:	4630      	mov	r0, r6
1a001b3c:	e722      	b.n	1a001984 <__udivdi3+0x8c>
1a001b3e:	42a9      	cmp	r1, r5
1a001b40:	d995      	bls.n	1a001a6e <__udivdi3+0x176>
1a001b42:	f1a8 0802 	sub.w	r8, r8, #2
1a001b46:	441d      	add	r5, r3
1a001b48:	e792      	b.n	1a001a70 <__udivdi3+0x178>
1a001b4a:	458c      	cmp	ip, r1
1a001b4c:	d9a0      	bls.n	1a001a90 <__udivdi3+0x198>
1a001b4e:	3c02      	subs	r4, #2
1a001b50:	4419      	add	r1, r3
1a001b52:	e79e      	b.n	1a001a92 <__udivdi3+0x19a>
1a001b54:	4610      	mov	r0, r2
1a001b56:	e7df      	b.n	1a001b18 <__udivdi3+0x220>
1a001b58:	460e      	mov	r6, r1
1a001b5a:	e7c9      	b.n	1a001af0 <__udivdi3+0x1f8>
1a001b5c:	3802      	subs	r0, #2
1a001b5e:	4429      	add	r1, r5
1a001b60:	e743      	b.n	1a0019ea <__udivdi3+0xf2>
1a001b62:	bf00      	nop

1a001b64 <__libc_init_array>:
1a001b64:	b570      	push	{r4, r5, r6, lr}
1a001b66:	4b0e      	ldr	r3, [pc, #56]	; (1a001ba0 <__libc_init_array+0x3c>)
1a001b68:	4c0e      	ldr	r4, [pc, #56]	; (1a001ba4 <__libc_init_array+0x40>)
1a001b6a:	1ae4      	subs	r4, r4, r3
1a001b6c:	10a4      	asrs	r4, r4, #2
1a001b6e:	2500      	movs	r5, #0
1a001b70:	461e      	mov	r6, r3
1a001b72:	42a5      	cmp	r5, r4
1a001b74:	d004      	beq.n	1a001b80 <__libc_init_array+0x1c>
1a001b76:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
1a001b7a:	4798      	blx	r3
1a001b7c:	3501      	adds	r5, #1
1a001b7e:	e7f8      	b.n	1a001b72 <__libc_init_array+0xe>
1a001b80:	f7fe fe46 	bl	1a000810 <_init>
1a001b84:	4c08      	ldr	r4, [pc, #32]	; (1a001ba8 <__libc_init_array+0x44>)
1a001b86:	4b09      	ldr	r3, [pc, #36]	; (1a001bac <__libc_init_array+0x48>)
1a001b88:	1ae4      	subs	r4, r4, r3
1a001b8a:	10a4      	asrs	r4, r4, #2
1a001b8c:	2500      	movs	r5, #0
1a001b8e:	461e      	mov	r6, r3
1a001b90:	42a5      	cmp	r5, r4
1a001b92:	d004      	beq.n	1a001b9e <__libc_init_array+0x3a>
1a001b94:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
1a001b98:	4798      	blx	r3
1a001b9a:	3501      	adds	r5, #1
1a001b9c:	e7f8      	b.n	1a001b90 <__libc_init_array+0x2c>
1a001b9e:	bd70      	pop	{r4, r5, r6, pc}
1a001ba0:	1a001e28 	.word	0x1a001e28
1a001ba4:	1a001e28 	.word	0x1a001e28
1a001ba8:	1a001e2c 	.word	0x1a001e2c
1a001bac:	1a001e28 	.word	0x1a001e28

1a001bb0 <memset>:
1a001bb0:	4402      	add	r2, r0
1a001bb2:	4603      	mov	r3, r0
1a001bb4:	4293      	cmp	r3, r2
1a001bb6:	d002      	beq.n	1a001bbe <memset+0xe>
1a001bb8:	f803 1b01 	strb.w	r1, [r3], #1
1a001bbc:	e7fa      	b.n	1a001bb4 <memset+0x4>
1a001bbe:	4770      	bx	lr

1a001bc0 <USB_DeviceQualifier>:
1a001bc0:	060a 0200 0000 4000 0001                    .......@..

1a001bca <Keyboard_ReportDescSize>:
1a001bca:	003f                                        ?.

1a001bcc <USB_StringDescriptor>:
1a001bcc:	0304 0409 031c 0054 0044 0020 0032 0030     ......T.D. .2.0.
1a001bdc:	0032 0032 0020 002d 0020 0055 004e 0054     2.2. .-. .U.N.T.
1a001bec:	031c 0045 0044 0055 0043 0049 0041 0041     ..E.D.U.C.I.A.A.
1a001bfc:	0020 0054 0045 0043 004c 0041 0044 004f      .T.E.C.L.A.D.O.
1a001c0c:	031c 0046 0020 004a 0055 0041 0052 0045     ..F. .J.U.A.R.E.
1a001c1c:	005a 0020 0059 0045 004c 0041 004d 004f     Z. .Y.E.L.A.M.O.
1a001c2c:	0053 0314 0048 0049 0044 0020 004b 0045     S...H.I.D. .K.E.
1a001c3c:	0059 0042 004f 0041 0052 0044               Y.B.O.A.R.D.

1a001c48 <Keyboard_ReportDescriptor>:
1a001c48:	0105 0609 01a1 0705 e019 e729 0015 0125     ..........)...%.
1a001c58:	0175 0895 0281 0195 0875 0181 0595 0175     u.......u.....u.
1a001c68:	0805 0119 0529 0291 0195 0375 0191 0695     ....).....u.....
1a001c78:	0875 0015 ff25 0705 0019 ff29 0081 ffc0     u...%.....).....

1a001c88 <USB_DeviceDescriptor>:
1a001c88:	0112 0200 0000 4000 1fc9 0086 0100 0201     .......@........
1a001c98:	0103 ffff                                   ....

1a001c9c <GpioPorts>:
1a001c9c:	0003 0303 0403 0f05 1005 0503 0603 0703     ................
1a001cac:	0802 ffff                                   ....

1a001cb0 <OscRateIn>:
1a001cb0:	1b00 00b7                                   ....

1a001cb4 <ExtRateIn>:
1a001cb4:	0000 0000                                   ....

1a001cb8 <GpioButtons>:
1a001cb8:	0400 0800 0900 0901                         ........

1a001cc0 <GpioLeds>:
1a001cc0:	0005 0105 0205 0e00 0b01 0c01               ............

1a001ccc <InitClkStates>:
1a001ccc:	0f01 0101                                   ....

1a001cd0 <pinmuxing>:
1a001cd0:	0002 0044 0102 0044 0202 0044 0a02 0040     ..D...D...D...@.
1a001ce0:	0b02 0040 0c02 0040 0001 0050 0101 0050     ..@...@...P...P.
1a001cf0:	0201 0050 0601 0050 0106 0050 0406 0050     ..P...P...P...P.
1a001d00:	0506 0050 0706 0054 0806 0054 0906 0050     ..P...T...T...P.
1a001d10:	0a06 0050 0b06 0050 0c06 0050 040f 00f0     ..P...P...P.....
1a001d20:	0301 00d5 0401 00d5 0107 0016 0207 0056     ..............V.
1a001d30:	0302 0052 0402 0052 0509 0052 0609 0057     ..R...R...R...W.
1a001d40:	0206 0057                                   ..W.

1a001d44 <UART_BClock>:
1a001d44:	01c2 01a2 0182 0162                         ......b.

1a001d4c <UART_PClock>:
1a001d4c:	0081 0082 00a1 00a2 0201 0804 0f03 0f0f     ................
1a001d5c:	00ff 0000                                   ....

1a001d60 <periph_to_base>:
1a001d60:	0000 0005 000a 0020 0024 0009 0040 0040     ...... .$...@.@.
1a001d70:	0005 0060 00a6 0004 00c0 00c3 0002 00e0     ..`.............
1a001d80:	00e0 0001 0100 0100 0003 0120 0120 0006     .......... . ...
1a001d90:	0140 0140 000c 0142 0142 0019 0162 0162     @.@...B.B...b.b.
1a001da0:	0013 0182 0182 0012 01a2 01a2 0011 01c2     ................
1a001db0:	01c2 0010 01e2 01e2 000f 0202 0202 000e     ................
1a001dc0:	0222 0222 000d 0223 0223 001c               "."...#.#...

1a001dcc <usbPLLSetup>:
1a001dcc:	601d 0000 7ffa 0616 0000 0000 0000 0000     .`..............
1a001ddc:	3800 1c9c                                   .8..

1a001de0 <InitClkStates>:
1a001de0:	0100 0001 0909 0001 090a 0001 0701 0101     ................
1a001df0:	0902 0001 0906 0001 090c 0101 090d 0001     ................
1a001e00:	090e 0001 090f 0001 0910 0001 0911 0001     ................
1a001e10:	0912 0001 0913 0001 1114 0001 1119 0001     ................
1a001e20:	111a 0001 111b 0001                         ........
